"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityManager = void 0;
const node_1 = require("@iota/identity-wasm/node");
const identity_stronghold_nodejs_1 = require("@iota/identity-stronghold-nodejs");
const util_1 = require("util");
const client_config_1 = require("./client-config");
const identity_account_1 = require("./IdentityAccount/identity-account");
const fs = require("fs");
const path = require("path");
const storage_driver_types_interface_1 = require("./StorageDriver/drivers/storage-driver.types.interface");
const fs_driver_1 = require("./StorageDriver/drivers/fs-driver/fs-driver");
const mongo_driver_1 = require("./StorageDriver/drivers/mongo-driver/mongo-driver");
const crypto_1 = require("./utils/crypto");
const fsReadFile = (0, util_1.promisify)(fs.readFile);
const fsWriteFile = (0, util_1.promisify)(fs.writeFile);
/**
 * IdentityManager is a utility class which handles management of secrets and
 * DID documents stored inside of one stronghold backup, private constructor needs
 * a path and password
 */
class IdentityManager {
    /**
     * Constructor to create an instance of the class
     *
     * @param {String} filepath
     * @param {String} password
     */
    constructor(filepath, password, managerAlias) {
        this.filepath = filepath;
        this.password = password;
        this.managerAlias = managerAlias;
    }
    /**
     * Get the instance of IdentityManager, it will create a new instance of the class
     * shall one not already exist
     *
     * @param {IIdentityManagerProps} props
     * @returns {Promise<IdentityManager>}
     */
    static newInstance(props) {
        return __awaiter(this, void 0, void 0, function* () {
            const { filepath, password, managerAlias } = props;
            const identityManager = new IdentityManager(filepath, password, managerAlias);
            const strongholdPath = path.resolve(__dirname, filepath, `${managerAlias}.stronghold`);
            const storage = yield identity_stronghold_nodejs_1.Stronghold.build(strongholdPath, password);
            const autopublish = false;
            const builder = new node_1.AccountBuilder({
                storage,
                clientConfig: client_config_1.clientConfig,
                autopublish,
            });
            identityManager.builder = builder;
            return identityManager;
        });
    }
    /**
     * Get the IdentityConfig document stored on a JSON
     *
     * @returns {Promise<IdentityConfig[]>}
     */
    getIdentityConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const identityPath = path.resolve(__dirname, this.filepath, `${this.managerAlias}-config.json`);
            return JSON.parse((yield fsReadFile(identityPath)).toString());
        });
    }
    /**
     * Get config of a did by the did tag
     *
     * @param {DID} did - tag of the did to fetch
     * @returns {Promise<IdentityConfig>}
     */
    getIdentityConfigByDid(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const configs = yield this.getIdentityConfig();
            const config = configs.find((c) => c.did === did);
            config.store.type =
                config.store.type === "FS"
                    ? fs_driver_1.FsStorageDriver
                    : config.store.type === "Mongo"
                        ? mongo_driver_1.MongoStorageDriver
                        : config.store.type;
            return config;
        });
    }
    /**
     * Get config of a did by the did alias
     *
     * @param {DID} did - tag of the did to fetch
     * @returns {Promise<IdentityConfig>}
     */
    getIdentityConfigByAlias(alias) {
        return __awaiter(this, void 0, void 0, function* () {
            const configs = yield this.getIdentityConfig();
            const config = configs.find((c) => c.alias === alias);
            config.store.type =
                config.store.type === "FS"
                    ? fs_driver_1.FsStorageDriver
                    : config.store.type === "Mongo"
                        ? mongo_driver_1.MongoStorageDriver
                        : config.store.type;
            return config;
        });
    }
    /**
     * Load a DID stored in the same stronghold path as the one configured
     *
     * @param {DID} did
     * @returns {Promise<IdentityAccount>}
     */
    getDid(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const { store } = yield this.getIdentityConfigByDid(did);
            const account = yield this.builder.loadIdentity(did);
            return yield identity_account_1.IdentityAccount.build({ account, store });
        });
    }
    /**
     * Create a new DID in the stronghold path as the one configured
     *
     * @param {IIdentityManagerProps} props - Alias for the identity
     * @returns {Promise<IdentityAccount>}
     */
    createDid(props) {
        return __awaiter(this, void 0, void 0, function* () {
            const { alias, store } = props;
            const account = yield this.builder.createIdentity();
            yield account.publish();
            let identities = [];
            const document = account.document();
            const did = account.did();
            const identityPath = path.resolve(__dirname, this.filepath, `${this.managerAlias}-config.json`);
            try {
                identities = yield this.getIdentityConfig();
                const aliasExists = identities.find((i) => i.alias === alias);
                if (aliasExists) {
                    throw new Error(`Alias \`${alias}\` already in use`);
                }
                // eslint-disable-next-line  @typescript-eslint/no-explicit-any
            }
            catch (error) {
                if (error.code !== "ENOENT") {
                    throw new Error(error);
                }
            }
            const storeCopy = Object.assign(Object.assign({}, store), { type: storage_driver_types_interface_1.Types.Fs ? "FS" : store.type === storage_driver_types_interface_1.Types.Mongo ? "Mongo" : store.type });
            identities = [
                ...identities,
                {
                    alias,
                    document,
                    did,
                    store: storeCopy,
                },
            ];
            yield fsWriteFile(identityPath, JSON.stringify(identities)).catch(() => {
                throw new Error("Unable to write IdentityConfig");
            });
            return yield identity_account_1.IdentityAccount.build({ account, store });
        });
    }
    /**
     * Gets an account by the alias stored in the config
     *
     * @param alias
     * @returns {Promise<IdentityAccount>}
     */
    getIdentityByAlias(alias) {
        return __awaiter(this, void 0, void 0, function* () {
            const identity = yield this.getIdentityConfigByAlias(alias);
            if (!identity)
                throw new Error("Identity not found");
            const account = yield this.builder.loadIdentity(node_1.DID.fromJSON(identity.did));
            return yield identity_account_1.IdentityAccount.build({ account, store: identity.store });
        });
    }
    /**
     * Create a backup of the identity manager with all of the identities stored
     * in the same vault
     *
     * @param {string} password - password to stronghold
     * @returns {Promise<IManagerBackup>}
     */
    createBackup(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const strongholdPath = path.resolve(__dirname, this.filepath, `${this.managerAlias}.stronghold`);
            const stronghold = (yield fsReadFile(strongholdPath)).toString();
            const config = yield this.getIdentityConfig();
            const credentials = yield Promise.all(config.map((config) => __awaiter(this, void 0, void 0, function* () {
                const identity = yield this.getIdentityByAlias(config.alias);
                const creds = yield identity.credentials.store.findAll();
                return { alias: creds };
            })));
            const backup = {
                stronghold: (0, crypto_1.encrypt)(stronghold, password),
                config: (0, crypto_1.encrypt)(JSON.stringify(config), password),
                credentials: (0, crypto_1.encrypt)(JSON.stringify(credentials), password),
            };
            return backup;
        });
    }
    /**
     * Take a `IManagerBackup` and then use it to restore identity manager to a
     * version and restore all the identities
     */
    static restoreFromBackup(backup, password, filepath, managerAlias) {
        return __awaiter(this, void 0, void 0, function* () {
            const credAccounts = (0, crypto_1.decrypt)(backup.credentials, password) !== ""
                ? JSON.parse((0, crypto_1.decrypt)(backup.credentials, password))
                : [];
            const configsRaw = JSON.parse((0, crypto_1.decrypt)(backup.config, password));
            const stronghold = (0, crypto_1.decrypt)(backup.stronghold, password);
            yield fsWriteFile(path.resolve(__dirname, filepath, `${managerAlias}.stronghold`), stronghold);
            const configs = configsRaw.map((c) => {
                return Object.assign(Object.assign({}, c), { store: {
                        type: storage_driver_types_interface_1.Types.Fs,
                        options: {
                            filepath: `${c.alias}`,
                        },
                    } });
            });
            yield fsWriteFile(path.resolve(__dirname, filepath, `${managerAlias}-config.json`), JSON.stringify(configs));
            const identityManager = new IdentityManager(filepath, password, managerAlias);
            const strongholdPath = path.resolve(__dirname, filepath, `${managerAlias}.stronghold`);
            const storage = yield identity_stronghold_nodejs_1.Stronghold.build(strongholdPath, password);
            const autopublish = false;
            const builder = new node_1.AccountBuilder({
                storage,
                clientConfig: client_config_1.clientConfig,
                autopublish,
            });
            identityManager.builder = builder;
            for (const credAccount of Object.keys(credAccounts)) {
                const did = yield identityManager.getIdentityByAlias(credAccount);
                for (const cred of credAccounts[credAccount]) {
                    did.credentials.store.newCredential(cred);
                }
            }
            return identityManager;
        });
    }
}
exports.IdentityManager = IdentityManager;
//# sourceMappingURL=identity-manager.js.map