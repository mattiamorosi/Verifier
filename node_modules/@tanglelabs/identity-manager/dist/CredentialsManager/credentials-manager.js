"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsManager = void 0;
const node_1 = require("@iota/identity-wasm/node");
const fragment_constants_1 = require("../constants/fragment.constants");
const storage_driver_1 = require("../StorageDriver/drivers/storage-driver");
const utils_1 = require("../utils");
/**
 * Credentials Manager is a helper class which contains all the abstractions for creating
 * new credentials, DVID and revokation of credentials
 */
class CredentialsManager {
    constructor(props) {
        const { account } = props;
        this.account = account;
        this.revocationEndpoint = fragment_constants_1.RevocationFragment;
    }
    static build(props) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialsManager = new CredentialsManager(props);
            yield credentialsManager.buildStore(props.store);
            return credentialsManager;
        });
    }
    buildStore(props) {
        return __awaiter(this, void 0, void 0, function* () {
            this.store = yield (0, storage_driver_1.buildStorageDriver)(Object.assign({}, props), this.encryptData, this.decryptData, this.account);
        });
    }
    /**
     * Validate a credential
     *
     * @param {Credential} signedVc - signed VC that needs to be validated
     * @param {ResolvedDocument} issuerIdentity - account it was signed with
     * @returns {Promise<boolean>}
     */
    isCredentialValid(signedVc, issuerIdentity) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.isCredentialValid)(signedVc, issuerIdentity);
        });
    }
    /**
     * DVID v0.2.0
     * Domain Verifiable Identity is a module that allows you to verify the source of
     * origin for a verifiable credential, here are the steps to validate with DVID v0.2.0
     *
     * - Parse the Document and look for the domain of origin
     * - Lookup TXT records for the domain of origin
     * - Resolve DID contained in DNS record and validate the credential
     *
     * @param {Credential} signedVc
     * @returns {{ vc: boolean, dvid: boolean}}
     */
    verifyCredential(signedVc) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.verifyCredential)(signedVc);
        });
    }
    /**
     * Create and issue a verifiable credential for someone
     *
     * @param {ICreateCredentialProps} props
     * @returns {Promise<Credential>}
     */
    create(props) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, recipientDid, fragment, body, type, keyIndex } = props;
            const credentialSubject = Object.assign({ id: recipientDid }, body);
            const issuer = this.account.document().id().toString();
            const unsignedCredential = new node_1.Credential({
                id,
                type,
                issuer,
                credentialSubject,
                credentialStatus: {
                    id: this.account.did() + this.revocationEndpoint,
                    type: node_1.RevocationBitmap.type(),
                    revocationBitmapIndex: keyIndex.toString(),
                },
            });
            const signedVc = yield this.account.createSignedCredential(fragment, unsignedCredential, node_1.ProofOptions.default());
            return signedVc;
        });
    }
    /**
     * Revoke a credential that has been issued, by revoking the method that was used to
     * sign the credential we are looking to revoke and make invalid.
     *
     * WARNING: it will revoke the method that was attached to the credential thus any other
     * credentials signed using this keypair will also become invalid
     *
     * @param {Number} keyIndex - Revoke the key at the index passed
     * @return {Promise<void>}
     */
    revokeCredential(keyIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.account.revokeCredentials(this.revocationEndpoint, keyIndex);
            yield this.account.publish();
        });
    }
    /**
     * Encrypt data and return it
     *
     * @param {String} plainText - data to be encrypted
     * @returns {Promise<EncryptedData>}
     */
    encryptData(plainText, account = this.account) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = account.document().resolveMethod(fragment_constants_1.EncryptionFragment);
            if (!method)
                throw new Error("Method not found");
            const publicKey = method.data().tryDecode();
            const agreementInfo = new node_1.AgreementInfo(new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0));
            const encryptionAlgorithm = node_1.EncryptionAlgorithm.A256GCM();
            const cekAlgorithm = node_1.CekAlgorithm.EcdhEs(agreementInfo);
            const message = Buffer.from(plainText);
            const associatedData = Buffer.from("associatedData");
            const encryptedData = yield this.account
                .encryptData(message, associatedData, encryptionAlgorithm, cekAlgorithm, publicKey)
                .catch((err) => {
                console.error(err);
            });
            if (!encryptedData)
                throw new Error("failed to encrypt data");
            return encryptedData;
        });
    }
    /**
     * Decrypt the data
     *
     * @param {EncryptedData | JSON | Record<string, unknown>} encryptedData - data to decrypt
     * @returns {Promise<string>}
     */
    decryptData(encryptedData) {
        return __awaiter(this, void 0, void 0, function* () {
            encryptedData =
                encryptedData instanceof node_1.EncryptedData
                    ? encryptedData
                    : node_1.EncryptedData.fromJSON(encryptedData);
            const agreementInfo = new node_1.AgreementInfo(new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0));
            const encryptionAlgorithm = node_1.EncryptionAlgorithm.A256GCM();
            const cekAlgorithm = node_1.CekAlgorithm.EcdhEs(agreementInfo);
            const decryptedData = yield this.account.decryptData(encryptedData, encryptionAlgorithm, cekAlgorithm, fragment_constants_1.EncryptionFragment);
            const plainText = new TextDecoder().decode(decryptedData);
            return plainText;
        });
    }
}
exports.CredentialsManager = CredentialsManager;
//# sourceMappingURL=credentials-manager.js.map