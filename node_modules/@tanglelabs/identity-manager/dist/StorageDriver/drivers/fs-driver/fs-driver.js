"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsStorageDriver = void 0;
const fs_1 = require("fs");
const node_1 = require("@iota/identity-wasm/node");
const util_1 = require("util");
const fsReadFile = (0, util_1.promisify)(fs_1.readFile);
const fsWriteFile = (0, util_1.promisify)(fs_1.writeFile);
class FsStorageDriver {
    constructor(options) {
        this.filepath = options.filepath;
    }
    /**
     * Instantiate a new instance of FsStorageDriver
     *
     * @param {IFsDriverProps} options - options object for FsStorageDriver
     * @returns {Promise<FsStorageDriver>}
     */
    static newInstance(options, encryptMethod, decryptMethod, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const fsDriver = new FsStorageDriver(options);
            fsDriver.encryptData = encryptMethod;
            fsDriver.decryptData = decryptMethod;
            fsDriver.account = account;
            yield this.instantiateFile(options);
            return fsDriver;
        });
    }
    /**
     * Creates a file if it doesn't exist
     *
     * @returns {Promise<void>}
     */
    static instantiateFile(options) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line  @typescript-eslint/no-explicit-any
            const fileData = yield fsReadFile(options.filepath).catch((error) => {
                if (error.code !== "ENOENT")
                    throw new Error(error);
            });
            if (fileData)
                return;
            yield fsWriteFile(options.filepath, JSON.stringify([])).catch(() => {
                throw new Error("FS ERROR: Unable to write to file");
            });
        });
    }
    /**
     * Get the file contents of the file stored at the configured storage path
     *
     * @returns {Promise<Credential[]>}
     */
    getFileContents() {
        return __awaiter(this, void 0, void 0, function* () {
            const fileData = yield fsReadFile(this.filepath).catch(() => {
                throw new Error("FS ERROR: Unable to read file data");
            });
            return fileData.toString() !== "" ? JSON.parse(fileData.toString()) : [];
        });
    }
    /**
     * Write the contents passed to the file configured at storage path
     *
     * @param {Credential[]} data - data to write to the file
     * @returns {Promise<void>}
     */
    writeFileContents(data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield fsWriteFile(this.filepath, JSON.stringify(data)).catch(() => {
                throw new Error("FS ERROR: Unable to write to file");
            });
        });
    }
    /**
     * Get all of the credentials stored
     *
     * @returns {Promise<Credential[]>}
     */
    findAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all((yield this.getFileContents()).map((c) => __awaiter(this, void 0, void 0, function* () {
                return node_1.Credential.fromJSON(JSON.parse(yield this.decryptData(c.credential, this.account)));
            })));
        });
    }
    /**
     * Find a Credential by it's ID
     *
     * @param {String} id
     * @returns {Promise<Credential[]>}
     */
    findById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const creds = yield this.getFileContents();
            const cred = creds.find((c) => c.id === id);
            if (!cred)
                throw new Error("Credential not found");
            const credentialRaw = JSON.parse(yield this.decryptData(cred.credential, this.account));
            return node_1.Credential.fromJSON(credentialRaw);
        });
    }
    /**
     * Filter all creds with a specific credential type
     *
     * @param {String} credType - type of the credential to look for
     * @returns {Promise<Credential[]>}
     */
    findByCredentialType(credType) {
        return __awaiter(this, void 0, void 0, function* () {
            const creds = yield this.getFileContents();
            return yield Promise.all(creds
                .filter((c) => c.type.includes(credType))
                .map((c) => __awaiter(this, void 0, void 0, function* () {
                const credentialRaw = JSON.parse(yield this.decryptData(c.credential, this.account));
                return node_1.Credential.fromJSON(credentialRaw);
            })));
        });
    }
    /**
     * Filter all creds issued by a specific issuer
     *
     * @param {String} issuer
     * @returns {Promise<Credential[]>}
     */
    findByIssuer(issuer) {
        return __awaiter(this, void 0, void 0, function* () {
            const creds = yield this.getFileContents();
            return yield Promise.all(creds
                .filter((c) => c.issuer === issuer)
                .map((c) => __awaiter(this, void 0, void 0, function* () {
                const credentialRaw = JSON.parse(yield this.decryptData(c.credential, this.account));
                return node_1.Credential.fromJSON(credentialRaw);
            })));
        });
    }
    /**
     * Save a new credential to the driver
     *
     * @param {Credential} cred - credential to add to FS
     * @returns {Promise<void>}
     */
    newCredential(cred) {
        return __awaiter(this, void 0, void 0, function* () {
            const storedCredentials = yield this.getFileContents();
            const credentialExists = storedCredentials.find((c) => c.id === cred.id());
            if (credentialExists)
                throw new Error("credential already exists");
            const creds = yield this.getFileContents();
            const encrypted = yield this.encryptData(JSON.stringify(cred.toJSON()), this.account);
            const storedCred = {
                id: cred.id(),
                type: cred.type(),
                issuer: cred.issuer(),
                credential: encrypted.toJSON(),
            };
            this.writeFileContents([...creds, storedCred]);
            return storedCred;
        });
    }
    /**
     * Delete a credential by ID
     *
     * @param {String} id - id of the credential to delete
     * @returns {Promise<void>}
     */
    delete(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const creds = yield this.getFileContents();
            const credsFiltered = creds.filter((c) => c.id !== id);
            yield this.writeFileContents(credsFiltered);
        });
    }
    /**
     * Cleanup
     */
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
}
exports.FsStorageDriver = FsStorageDriver;
//# sourceMappingURL=fs-driver.js.map