"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoStorageDriver = void 0;
const node_1 = require("@iota/identity-wasm/node");
const mongoose_1 = require("mongoose");
const stored_vc_schema_1 = require("./stored-vc.schema");
class MongoStorageDriver {
    constructor(options) {
        this.mongouri = options.mongouri;
    }
    /**
     * Instantiate a new instance of FsStorageDriver
     *
     * @param {IFsDriverOpts} options - options object for FsStorageDriver
     * @returns {Promise<FsStorageDriver>}
     */
    static newInstance(options, encryptMethod, decryptMethod, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const mongoDriver = new MongoStorageDriver(options);
            mongoDriver.encryptData = encryptMethod;
            mongoDriver.decryptData = decryptMethod;
            mongoDriver.account = account;
            yield this.connectMongoDb(options.mongouri);
            return mongoDriver;
        });
    }
    static connectMongoDb(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            yield mongoose_1.default.connect(uri).catch((err) => {
                throw new Error(`unable to connect to mongodb: ${err}`);
            });
        });
    }
    /**
     * Get all of the credentials stored
     *
     * @returns {Promise<Credential[]>}
     */
    findAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all((yield stored_vc_schema_1.StoredVc.find({})).map((c) => __awaiter(this, void 0, void 0, function* () {
                return node_1.Credential.fromJSON(JSON.parse(yield this.decryptData(c.credential, this.account)));
            })));
        });
    }
    /**
     * Find a Credential by it's ID
     *
     * @param {String} id
     * @returns {Promise<Credential[]>}
     */
    findById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundCredRaw = yield stored_vc_schema_1.StoredVc.findOne({ id });
            if (!foundCredRaw)
                throw new Error("Credential Not found");
            return node_1.Credential.fromJSON(JSON.parse(yield this.decryptData(foundCredRaw.credential, this.account)));
        });
    }
    /**
     * Filter all creds with a specific credential type
     *
     * @param {String} credType - type of the credential to look for
     * @returns {Promise<Credential[]>}
     */
    findByCredentialType(credType) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundCredsRaw = yield stored_vc_schema_1.StoredVc.find({ type: { $in: [credType] } });
            if (!foundCredsRaw)
                throw new Error("Credentials Not found");
            return Promise.all(foundCredsRaw.map((c) => __awaiter(this, void 0, void 0, function* () {
                return node_1.Credential.fromJSON(JSON.parse(yield this.decryptData(c.credential, this.account)));
            })));
        });
    }
    /**
     * Filter all creds issued by a specific issuer
     *
     * @param {String} issuer
     * @returns {Promise<Credential[]>}
     */
    findByIssuer(issuer) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundCredsRaw = yield stored_vc_schema_1.StoredVc.find({ issuer });
            if (!foundCredsRaw)
                throw new Error("Credentials Not found");
            return Promise.all(foundCredsRaw.map((c) => __awaiter(this, void 0, void 0, function* () {
                return node_1.Credential.fromJSON(JSON.parse(yield this.decryptData(c.credential, this.account)));
            })));
        });
    }
    /**
     * Save a new credential to the driver
     *
     * @param {Credential} cred - credential to add to FS
     * @returns {Promise<void>}
     */
    newCredential(cred) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentialExists = yield stored_vc_schema_1.StoredVc.findOne({ id: cred.id() });
            if (credentialExists)
                throw new Error("credential already exists");
            const encrypted = yield this.encryptData(JSON.stringify(cred.toJSON()), this.account);
            const storedCred = yield stored_vc_schema_1.StoredVc.create({
                id: cred.id(),
                type: cred.type(),
                issuer: cred.issuer(),
                credential: encrypted.toJSON(),
            });
            return storedCred;
        });
    }
    /**
     * Delete a credential by ID
     *
     * @param {String} id - id of the credential to delete
     * @returns {Promise<void>}
     */
    delete(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield stored_vc_schema_1.StoredVc.findOneAndDelete({ id });
        });
    }
    /**
     * cleanup mongo connection gracefully
     */
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield mongoose_1.default.disconnect();
        });
    }
}
exports.MongoStorageDriver = MongoStorageDriver;
//# sourceMappingURL=mongo-driver.js.map