/* tslint:disable */
/* eslint-disable */
/**
* Initializes the console error panic hook for better error messages
*/
export function start(): void;
/**
*/
export enum DIDMessageEncoding {
  Json,
  JsonBrotli,
}
/**
* Controls validation behaviour when checking whether or not a credential has been revoked by its
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status).
*/
export enum StatusCheck {
/**
* Validate the status if supported, reject any unsupported
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status) types.
*
* Only `RevocationBitmap2022` is currently supported.
*
* This is the default.
*/
  Strict,
/**
* Validate the status if supported, skip any unsupported
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status) types.
*/
  SkipUnsupported,
/**
* Skip all status checks.
*/
  SkipAll,
}
/**
* Declares how credential subjects must relate to the presentation holder during validation.
* See `PresentationValidationOptions::subject_holder_relationship`.
*
* See also the [Subject-Holder Relationship](https://www.w3.org/TR/vc-data-model/#subject-holder-relationships) section of the specification.
*/
export enum SubjectHolderRelationship {
/**
* The holder must always match the subject on all credentials, regardless of their [`nonTransferable`](https://www.w3.org/TR/vc-data-model/#nontransferable-property) property.
* This variant is the default used if no other variant is specified when constructing a new
* `PresentationValidationOptions`.
*/
  AlwaysSubject,
/**
* The holder must match the subject only for credentials where the [`nonTransferable`](https://www.w3.org/TR/vc-data-model/#nontransferable-property) property is `true`.
*/
  SubjectOnNonTransferable,
/**
* The holder is not required to have any kind of relationship to any credential subject.
*/
  Any,
}
/**
* Declares when validation should return if an error occurs.
*/
export enum FailFast {
/**
* Return all errors that occur during validation.
*/
  AllErrors,
/**
* Return after the first error occurs.
*/
  FirstError,
}
/**
*/
export enum KeyType {
  Ed25519,
  X25519,
}
/**
*/
export enum MethodRelationship {
  Authentication,
  AssertionMethod,
  KeyAgreement,
  CapabilityDelegation,
  CapabilityInvocation,
}

/**
 * Options for attaching one or more verification relationships to a method on an identity.
 */
export type AttachMethodRelationshipOptions = {
    /**
     * The identifier of the method in the document.
     */
    fragment: string,

    /**
     * The relationships to add;
     */
    relationships: MethodRelationship | MethodRelationship[]
};



/**
 * Options for creating a new method on an identity.
 */
export type CreateMethodOptions = {
    /**
     * The identifier of the method in the document.
     */
    fragment: string,

    /**
     * The scope of the method, defaults to VerificationMethod.
     */
    scope?: MethodScope,

    /**
     * Method content for the new method.
     */
    content: MethodContent
  };



/**
 * Options for detaching one or more verification relationships from a method on an identity.
 */
export type DetachMethodRelationshipOptions = {
    /**
     * The identifier of the method in the document.
     */
    fragment: string,

    /**
     * The relationships to remove.
     */
    relationships: MethodRelationship | MethodRelationship[]
};



/** Holds options to create a new `VerifierOptions`. */
interface IVerifierOptions {
    /** Verify the signing verification method relationship matches this.
    *
    * NOTE: `purpose` overrides the `method_scope` option.
    */
    readonly methodScope?: MethodScope;

    /** Verify the signing verification method type matches one specified.
    *
    * E.g. `[MethodType.Ed25519VerificationKey2018(), MethodType.X25519KeyAgreementKey2019()]`
    */
    readonly methodType?: Array<MethodType>;

    /** Verify the `Proof.challenge` field matches this. */
    readonly challenge?: string;

    /** Verify the `Proof.domain` field matches this. */
    readonly domain?: string;

    /** Verify the `Proof.purpose` field matches this. Also verifies that the signing
    * method has the corresponding verification method relationship.
    *
    * NOTE: `purpose` overrides the `method_scope` option.
    */
    readonly purpose?: ProofPurpose;

    /** Determines whether to error if the current time exceeds the `Proof.expires` field.
    *
    * Default: false (reject expired signatures).
    */
    readonly allowExpired?: boolean;
}

/** Fields for constructing a new {@link Presentation}. */
interface IPresentation {
  /** The JSON-LD context(s) applicable to the `Presentation`. */
  readonly context?: string | Record<string, any> | Array<string | Record<string, any>>;
  /** A unique URI that may be used to identify the `Presentation`. */
  readonly id?: string;
  /** One or more URIs defining the type of the `Presentation`. Contains the base context by default. */
  readonly type?: string | Array<string>;
  /** Credential(s) expressing the claims of the `Presentation`. */
  readonly verifiableCredential: Credential | Array<Credential>;
  /** The entity that generated the `Presentation`. */
  readonly holder?: string | DID;
  /** Service(s) used to refresh an expired {@link Credential} in the `Presentation`. */
  readonly refreshService?: RefreshService | Array<RefreshService>;
  /** Terms-of-use specified by the `Presentation` holder. */
  readonly termsOfUse?: Policy | Array<Policy>;
  /** Miscellaneous properties. */
  readonly [properties: string]: unknown;
}


/**
 * Options to customize how identities are published to the Tangle.
**/
export type PublishOptions = {
    /**
     * Whether to force the publication to be an integration update.
     * If this option is not set, the account automatically determines whether
     * an update needs to be published as an integration or a diff update.
     * Publishing as an integration update is always valid, but not recommended
     * for identities with many updates.
     *
     * See the IOTA DID method specification for more details.
     *
     * @deprecated since 0.5.0, diff chain features are slated for removal.
     */
     forceIntegrationUpdate?: boolean,


    /**
     * Set the fragment of a verification method with which to sign the update.
     * This must point to an Ed25519 method with a capability invocation
     * verification relationship.
     *
     *  If omitted, the default signing method on the Document will be used.
     */
     signWith?: string
 }



/**
 * Configuration used to create a new Identity.
 */
export type IdentitySetup = {
    /**
     * Use a pre-generated Ed25519 private key for the DID.
     */
    privateKey?: Uint8Array,
};



/**
 * Options for creating a new {@link AccountBuilder}.
 */
export type AccountBuilderOptions = {

    /**
     * When the account will store its state to the storage.
     */
    autosave?: AutoSave

    /**
     * `autopublish == true` the account will publish messages to the tangle on each update.
     * `autopublish == false` the account will combine and publish message when .publish() is called.
     */
    autopublish?: boolean,

    /**
     * Client for tangle requests.
     */
    clientConfig?: IClientConfig,

    /**
     * The Storage implemantation to use for each account built by this builder.
     */
    storage?: Storage
};


/** IOTA node details with optional authentication. */
interface INodeAuth {
  readonly url: string;
  readonly jwt?: string;
  readonly username?: string;
  readonly password?: string;
}

/** {@link Client} configuration options. */
interface IClientConfig {
  /** Sets the IOTA Tangle network. */
  readonly network?: Network;
  /** Sets the DID message encoding used when publishing to the Tangle. */
  readonly encoding?: DIDMessageEncoding;
  /** Adds a list of IOTA nodes to use by their URLs. */
  readonly nodes?: Array<string>;
  /** Sets an IOTA node by its URL to be used as primary node. */
  readonly primaryNode?: INodeAuth;
  /** Adds an IOTA node by its URL to be used as primary PoW node (for remote PoW). */
  readonly primaryPowNode?: INodeAuth;
  /** Adds a list of IOTA permanodes by their URLs. */
  readonly permanodes?: Array<INodeAuth>;
  /** Adds a list of IOTA nodes to be used by their URLs. */
  readonly nodeAuth?: Array<INodeAuth>;
  /** Sets the node sync interval in seconds. */
  readonly nodeSyncInterval?: number;
  /** Disables the node sync process. */
  readonly nodeSyncDisabled?: boolean;
  /** Enables/disables quorum. */
  readonly quorum?: boolean;
  /** Sets the number of nodes used for quorum. */
  readonly quorumSize?: number;
  /** Sets the quorum threshold. */
  readonly quorumThreshold?: number;
  /** Sets whether proof-of-work (PoW) is performed locally or remotely. Default: false. */
  readonly localPow?: boolean;
  /** Sets whether the PoW should be done locally in case a node doesn't support remote PoW. Default: true. */
  readonly fallbackToLocalPow?: boolean;
  /** Sets the number of seconds that new tips will be requested during PoW. */
  readonly tipsInterval?: number;
  /** Sets the default request timeout. */
  readonly requestTimeout?: number;
  /** When publishing to the Tangle, sets whether to retry until the message is confirmed by a milestone. Default: true. */
  readonly retryUntilIncluded?: boolean;
}


/**
 * Options for setting the `alsoKnownAs` property.
 */
 export type SetAlsoKnownAsOptions = {

    /**
     * List of URLs for the `alsoKnownAs` property. Duplicates are ignored.
     */
    urls: string | string[] | null,
};



/**
 * Options for deleting a method on an identity.
 */
export type DeleteMethodOptions = {
    /**
     * The identifier of the method in the document.
     */
    fragment: string,
};



/**
 * Options for deleting a service on an identity.
 */
export type DeleteServiceOptions = {
    /**
     * The identifier of the service in the document.
     */
    fragment: string,
};



/**
 * Options for setting DID controllers.
 */
 export type SetControllerOptions = {

    /**
     * List of DIDs to be set as controllers, use `null` to remove all controllers.
     */
    controllers: DID | DID[] | null,
};



/** Holds options to create a new `ProofOptions`. */
interface IProofOptions {
    /** When the proof was generated. */
    readonly created?: Timestamp;

    /** When the proof expires. */
    readonly expires?: Timestamp;

    /** Challenge from a proof requester to mitigate replay attacks. */
    readonly challenge?: string;

    /** Domain for which a proof is valid to mitigate replay attacks. */
    readonly domain?: string;

    /** Purpose for which the proof was generated. */
    readonly purpose?: ProofPurpose;
}

/** Fields for constructing a new {@link Credential}. */
interface ICredential {
  /** The JSON-LD context(s) applicable to the `Credential`. */
  readonly context?: string | Record<string, any> | Array<string | Record<string, any>>;
  /** A unique URI that may be used to identify the `Credential`. */
  readonly id?: string;
  /** One or more URIs defining the type of the `Credential`. Contains the base context by default. */
  readonly type?: string | Array<string>;
  /** One or more objects representing the `Credential` subject(s). */
  readonly credentialSubject: Subject | Array<Subject>;
  /** A reference to the issuer of the `Credential`. */
  readonly issuer: string | DID | Issuer;
  /** A timestamp of when the `Credential` becomes valid. Defaults to the current datetime. */
  readonly issuanceDate?: Timestamp;
  /** A timestamp of when the `Credential` should no longer be considered valid. */
  readonly expirationDate?: Timestamp;
  /** Information used to determine the current status of the `Credential`. */
  readonly credentialStatus?: Status;
  /** Information used to assist in the enforcement of a specific `Credential` structure. */
  readonly credentialSchema?: Schema | Array<Schema>;
  /** Service(s) used to refresh an expired `Credential`. */
  readonly refreshService?: RefreshService | Array<RefreshService>;
  /** Terms-of-use specified by the `Credential` issuer. */
  readonly termsOfUse?: Policy | Array<Policy>;
  /** Human-readable evidence used to support the claims within the `Credential`. */
  readonly evidence?: Evidence | Array<Evidence>;
  /** Indicates that the `Credential` must only be contained within a {@link Presentation} with a proof issued from the `Credential` subject. */
  readonly nonTransferable?: boolean;
  /** Miscellaneous properties. */
  readonly [properties: string]: unknown;
}


/** Holds options to create a new `CredentialValidationOptions`. */
interface ICredentialValidationOptions {
    /** Declare that the credential is **not** considered valid if it expires before this `Timestamp`.
     * Uses the current datetime during validation if not set. */
    readonly earliestExpiryDate?: Timestamp;

    /** Declare that the credential is **not** considered valid if it was issued later than this `Timestamp`.
     * Uses the current datetime during validation if not set. */
    readonly latestIssuanceDate?: Timestamp;

    /** Validation behaviour for `credentialStatus`.
     *
     * Default: `StatusCheck.Strict`. */
    readonly status?: StatusCheck;

    /** Options which affect the verification of the signature on the credential. */
    readonly verifierOptions?: VerifierOptions;

}


/** Holds options to create a new `PresentationValidationOptions`. */
interface IPresentationValidationOptions {
    /** Declare that the credentials of the presentation must all be validated according to these `CredentialValidationOptions`. */
    readonly sharedValidationOptions?: CredentialValidationOptions;

    /** Options which affect the verification of the signature on the presentation. */
    readonly presentationVerifierOptions?: VerifierOptions;

    /** Declare how the presentation's credential subjects must relate to the holder.
     *
     * Default: SubjectHolderRelationship.AlwaysSubject
     */
    readonly subjectHolderRelationship?: SubjectHolderRelationship;

}


/**
 * Holds options to create a new `Service`.
 */
interface IService {
    /**
     * Identifier of the service.
     *
     * Must be a valid DIDUrl with a fragment.
     */
    readonly id: DIDUrl | string;

    /**
     * Type of service.
     *
     * E.g. "LinkedDomains" or "DIDCommMessaging".
     */
    readonly type: string;

    /**
     * A URL, set of URLs, or map of URL sets.
     *
     * NOTE: throws an error if any entry is not a valid URL string. List entries must be unique.
     */
    readonly serviceEndpoint: string | string[] | Map<string, string[]> | Record<string, string[]>;

    /**
     * Additional custom properties to embed in the service.
     *
     * WARNING: entries may overwrite existing fields and result in invalid documents.
     */
    readonly properties?: Map<string, any> | Record<string, any>;
}


/**
 * Options for creating a new service on an identity.
 */
export type CreateServiceOptions = {
  /**
   * The identifier of the service in the document.
   */
  fragment: string;

  /**
   * The type of the service.
   */
  type: string;

  /**
   * The `ServiceEndpoint` of the service.
   */
  endpoint: string | string[] | Map<string, string[]> | Record<string, string[]>;

  /**
   * Additional properties of the service.
   */
  properties?: Map<string, any> | Record<string, any>;
};



/** An interface for Account storage implementations.

The `Storage` interface is used for secure key operations, such as key generation and signing,
as well as key-value like storage of data structures, such as DID documents.

# Identifiers

Implementations of this interface are expected to uniquely identify keys through the
combination of DID _and_ `KeyLocation`.

An implementation recommendation is to use the DID as a partition key. Everything related to a DID
can be stored in a partition identified by that DID. Keys belonging to a DID can then be identified
by `KeyLocation`s in that partition.

# DID List

The storage is expected to maintain a list of stored DIDs. DIDs created with `did_create` should be
inserted into the list, and removed when calling `did_purge`.
Other operations on the list are `did_exists` and `did_list`.

# Implementation example

See the `MemStore` example for a test implementation. */
interface Storage {
  /** Creates a new identity for the given `network`.

   - Uses the given Ed25519 `private_key` or generates a new key if it's `None`.
   - Returns an error if the DID already exists.
   - Adds the newly created DID to a list which can be accessed via `did_list`.

   Returns the generated DID and the location at which the key was stored. */
  didCreate: (network: string, fragment: string, privateKey?: Uint8Array) => Promise<[DID, KeyLocation]>;

  /** Removes the keys and any other state for the given `did`.

   This operation is idempotent: it does not fail if the given `did` does not (or no longer) exist.

   Returns `true` if the did and its associated data was removed, `false` if nothing was done. */
  didPurge: (did: DID) => Promise<boolean>;

  /** Returns `true` if `did` exists in the list of stored DIDs. */
  didExists: (did: DID) => Promise<boolean>;

  /** Returns the list of stored DIDs. */
  didList: () => Promise<Array<DID>>;

  /** Generates a new key for the given `did` with the given `key_type` and `fragment` identifier
   and returns the location of the newly generated key. */
  keyGenerate: (did: DID, keyType: KeyType, fragment: string) => Promise<KeyLocation>;

  /** Inserts a private key at the specified `location`.

   If a key at `location` exists, it is overwritten. */
  keyInsert: (did: DID, keyLocation: KeyLocation, privateKey: Uint8Array) => Promise<void>;

  /** Retrieves the public key from `location`. */
  keyPublic: (did: DID, keyLocation: KeyLocation) => Promise<Uint8Array>;

  /** Deletes the key at `location`.

   This operation is idempotent: it does not fail if the key does not exist.

   Returns `true` if it removed the key, `false` if nothing was done. */
  keyDelete: (did: DID, keyLocation: KeyLocation) => Promise<boolean>;

  /** Signs `data` with the private key at the specified `location`. */
  keySign: (did: DID, keyLocation: KeyLocation, data: Uint8Array) => Promise<Signature>;

  /** Returns `true` if a key exists at the specified `location`. */
  keyExists: (did: DID, keyLocation: KeyLocation) => Promise<boolean>;

  /** Encrypts the given `plaintext` with the specified `encryptionAlgorithm` and `cekAlgorithm`.
   *
   *  Returns an `EncryptedData` instance.
   */
  dataEncrypt: (did: DID, plaintext: Uint8Array, associatedData: Uint8Array, encryptionAlgorithm: EncryptionAlgorithm, cekAlgorithm: CekAlgorithm, publicKey: Uint8Array) => Promise<EncryptedData>;

  /** Decrypts the given `data` with the specified `encryptionAlgorithm` and `cekAlgorithm`.
   *
   *  Returns the decrypted text.
   */
  dataDecrypt: (did: DID, data: EncryptedData, encryptionAlgorithm: EncryptionAlgorithm, cekAlgorithm: CekAlgorithm, privateKey: KeyLocation) => Promise<Uint8Array>;

  /** Returns the chain state of the identity specified by `did`. */
  chainStateGet: (did: DID) => Promise<ChainState | undefined>;

  /** Set the chain state of the identity specified by `did`. */
  chainStateSet: (did: DID, chainState: ChainState) => Promise<void>;

  /** Returns the document of the identity specified by `did`. */
  documentGet: (did: DID) => Promise<Document | undefined>;

  /** Sets a new state for the identity specified by `did`. */
  documentSet: (did: DID, document: Document) => Promise<void>;

  /** Persists any unsaved changes. */
  flushChanges: () => Promise<void>;
}


/** Information used to increase confidence in the claims of a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#evidence) */
interface Evidence {
  /** A URL that allows retrieval of information about the evidence. */
  readonly id?: string;
  /** The type(s) of the credential evidence. */
  readonly types: string | Array<string>;
  /** Additional properties of the credential evidence. */
  readonly [properties: string]: unknown;
}


/** An identifier representing the issuer of a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#issuer) */
interface Issuer {
  /** A URL identifying the credential issuer. */
  readonly id: string;
  /** Additional properties of the credential issuer. */
  readonly [properties: string]: unknown;
}


/** Information used to express obligations, prohibitions, and permissions about a {@link Credential} or {@link Presentation}.

[More Info](https://www.w3.org/TR/vc-data-model/#terms-of-use) */
interface Policy {
  /** A URL identifying the credential terms-of-use. */
  readonly id?: string;
  /** The type(s) of the credential terms-of-use. */
  readonly types: string | Array<string>;
  /** Additional properties of the credential terms-of-use. */
  readonly [properties: string]: unknown;
}


/** Information used to refresh or assert the status of a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#refreshing) */
interface RefreshService {
  /** The URL of the credential refresh service. */
  readonly id: string;
  /** The type(s) of the credential refresh service. */
  readonly types: string | Array<string>;
  /** Additional properties of the credential refresh service. */
  readonly [properties: string]: unknown;
}


/** Information used to validate the structure of a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#data-schemas) */
interface Schema {
  /** A URL identifying the credential schema file. */
  readonly id: string;
  /** The type(s) of the credential schema. */
  readonly types: string | Array<string>;
  /** Additional properties of the credential schema. */
  readonly [properties: string]: unknown;
}


/** Information used to determine the current status of a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#status) */
interface Status {
  /** A URL identifying the credential status. */
  readonly id: string;
  /** The type of the credential status. */
  readonly type: string;
  /** Additional properties of the credential status. */
  readonly [properties: string]: unknown;
}


/** An entity who is the target of a set of claims in a {@link Credential}.

[More Info](https://www.w3.org/TR/vc-data-model/#credential-subject) */
interface Subject {
  /** A URI identifying the credential subject. */
  readonly id?: string | DID;
  /** Additional properties of the credential subject. */
  readonly [properties: string]: unknown;
}

/**
* An account manages one identity.
*
* It handles private keys, writing to storage and
* publishing to the Tangle.
*/
export class Account {
  free(): void;
/**
* Attach one or more verification relationships to a method.
*
* Note: the method must exist and be in the set of verification methods;
* it cannot be an embedded method.
* @param {AttachMethodRelationshipOptions} options
* @returns {Promise<void>}
*/
  attachMethodRelationships(options: AttachMethodRelationshipOptions): Promise<void>;
/**
* Adds a new verification method to the DID document.
* @param {CreateMethodOptions} options
* @returns {Promise<void>}
*/
  createMethod(options: CreateMethodOptions): Promise<void>;
/**
* Detaches the given relationship from the given method, if the method exists.
* @param {DetachMethodRelationshipOptions} options
* @returns {Promise<void>}
*/
  detachMethodRelationships(options: DetachMethodRelationshipOptions): Promise<void>;
/**
* Returns the {@link DID} of the managed identity.
* @returns {DID}
*/
  did(): DID;
/**
* Returns whether auto-publish is enabled.
* @returns {boolean}
*/
  autopublish(): boolean;
/**
* Returns the auto-save configuration value.
* @returns {AutoSave}
*/
  autosave(): AutoSave;
/**
* Returns a copy of the document managed by the `Account`.
*
* Note: the returned document only has a valid signature after publishing an integration chain update.
* In general, for use cases where the signature is required, it is advisable to resolve the
* document from the Tangle.
* @returns {Document}
*/
  document(): Document;
/**
* Resolves the DID Document associated with this `Account` from the Tangle.
* @returns {Promise<ResolvedDocument>}
*/
  resolveIdentity(): Promise<ResolvedDocument>;
/**
* Removes the identity from the local storage entirely.
*
* Note: This will remove all associated document updates and key material - recovery is NOT POSSIBLE!
* @returns {Promise<void>}
*/
  deleteIdentity(): Promise<void>;
/**
* Push all unpublished changes to the tangle in a single message.
* @param {PublishOptions | undefined} publish_options
* @returns {Promise<void>}
*/
  publish(publish_options?: PublishOptions): Promise<void>;
/**
* Signs a {@link Credential} with the key specified by `fragment`.
* @param {string} fragment
* @param {Credential} credential
* @param {ProofOptions} options
* @returns {Promise<Credential>}
*/
  createSignedCredential(fragment: string, credential: Credential, options: ProofOptions): Promise<Credential>;
/**
* Signs a {@link Document} with the key specified by `fragment`.
* @param {string} fragment
* @param {Document} document
* @param {ProofOptions} options
* @returns {Promise<Document>}
*/
  createSignedDocument(fragment: string, document: Document, options: ProofOptions): Promise<Document>;
/**
* Signs a {@link Presentation} the key specified by `fragment`.
* @param {string} fragment
* @param {Presentation} presentation
* @param {ProofOptions} options
* @returns {Promise<Presentation>}
*/
  createSignedPresentation(fragment: string, presentation: Presentation, options: ProofOptions): Promise<Presentation>;
/**
* Signs arbitrary `data` with the key specified by `fragment`.
* @param {string} fragment
* @param {any} data
* @param {ProofOptions} options
* @returns {Promise<any>}
*/
  createSignedData(fragment: string, data: any, options: ProofOptions): Promise<any>;
/**
* Overwrites the {@link Document} this account manages, **without doing any validation**.
*
* ### WARNING
*
* This method is dangerous and can easily corrupt the internal state,
* potentially making the identity unusable. Only call this if you fully
* understand the implications!
* @param {Document} document
* @returns {Promise<void>}
*/
  updateDocumentUnchecked(document: Document): Promise<void>;
/**
* Fetches the latest changes from the tangle and **overwrites** the local document.
*
* If a DID is managed from distributed accounts, this should be called before making changes
* to the identity, to avoid publishing updates that would be ignored.
* @returns {Promise<void>}
*/
  fetchDocument(): Promise<void>;
/**
* If the document has a `RevocationBitmap` service identified by `fragment`,
* revoke all credentials with a `revocationBitmapIndex` in `credentialIndices`.
* @param {string} fragment
* @param {number | number[]} credentialIndices
* @returns {Promise<void>}
*/
  revokeCredentials(fragment: string, credentialIndices: number | number[]): Promise<void>;
/**
* If the document has a `RevocationBitmap` service identified by `fragment`,
* unrevoke all credentials with a `revocationBitmapIndex` in `credentialIndices`.
* @param {string} fragment
* @param {number | number[]} credentialIndices
* @returns {Promise<void>}
*/
  unrevokeCredentials(fragment: string, credentialIndices: number | number[]): Promise<void>;
/**
* Encrypts the given `plaintext` with the specified `encryption_algorithm` and `cek_algorithm`.
*
* Returns an [`EncryptedData`] instance.
* @param {Uint8Array} plaintext
* @param {Uint8Array} associated_data
* @param {EncryptionAlgorithm} encryption_algorithm
* @param {CekAlgorithm} cek_algorithm
* @param {Uint8Array} public_key
* @returns {Promise<EncryptedData>}
*/
  encryptData(plaintext: Uint8Array, associated_data: Uint8Array, encryption_algorithm: EncryptionAlgorithm, cek_algorithm: CekAlgorithm, public_key: Uint8Array): Promise<EncryptedData>;
/**
* Decrypts the given `data` with the key identified by `fragment` using the given `encryption_algorithm` and
* `cek_algorithm`.
*
* Returns the decrypted text.
* @param {EncryptedData} data
* @param {EncryptionAlgorithm} encryption_algorithm
* @param {CekAlgorithm} cek_algorithm
* @param {string} fragment
* @returns {Promise<Uint8Array>}
*/
  decryptData(data: EncryptedData, encryption_algorithm: EncryptionAlgorithm, cek_algorithm: CekAlgorithm, fragment: string): Promise<Uint8Array>;
/**
* Sets the `alsoKnownAs` property in the DID document.
* @param {SetAlsoKnownAsOptions} options
* @returns {Promise<void>}
*/
  setAlsoKnownAs(options: SetAlsoKnownAsOptions): Promise<void>;
/**
* Deletes a verification method if the method exists.
* @param {DeleteMethodOptions} options
* @returns {Promise<void>}
*/
  deleteMethod(options: DeleteMethodOptions): Promise<void>;
/**
* Deletes a Service if it exists.
* @param {DeleteServiceOptions} options
* @returns {Promise<void>}
*/
  deleteService(options: DeleteServiceOptions): Promise<void>;
/**
* Sets the controllers of the DID document.
* @param {SetControllerOptions} options
* @returns {Promise<void>}
*/
  setController(options: SetControllerOptions): Promise<void>;
/**
* Adds a new Service to the DID Document.
* @param {CreateServiceOptions} options
* @returns {Promise<void>}
*/
  createService(options: CreateServiceOptions): Promise<void>;
}
/**
* An [`Account`] builder for easy account configuration.
*
* To reduce memory usage, accounts created from the same builder share the same `Storage`
* used to store identities, and the same {@link Client} used to publish identities to the Tangle.
*
* The configuration on the other hand is cloned, and therefore unique for each built account.
* This means a builder can be reconfigured in-between account creations, without affecting
* the configuration of previously built accounts.
*/
export class AccountBuilder {
  free(): void;
/**
* Creates a new `AccountBuilder`.
* @param {AccountBuilderOptions | undefined} options
*/
  constructor(options?: AccountBuilderOptions);
/**
* Loads an existing identity with the specified `did` using the current builder configuration.
* The identity must exist in the configured `Storage`.
* @param {DID} did
* @returns {Promise<Account>}
*/
  loadIdentity(did: DID): Promise<Account>;
/**
* Creates a new identity based on the builder configuration and returns
* an {@link Account} object to manage it.
*
* The identity is stored locally in the `Storage`. The DID network is automatically determined
* by the {@link Client} used to publish it.
*
* @See {@link IdentitySetup} to customize the identity creation.
* @param {IdentitySetup | undefined} identity_setup
* @returns {Promise<Account>}
*/
  createIdentity(identity_setup?: IdentitySetup): Promise<Account>;
}
/**
* Agreement information used as the input for the concat KDF.
*/
export class AgreementInfo {
  free(): void;
/**
* Creates an `AgreementInfo` Object.
* @param {Uint8Array} apu
* @param {Uint8Array} apv
* @param {Uint8Array} pub_info
* @param {Uint8Array} priv_info
*/
  constructor(apu: Uint8Array, apv: Uint8Array, pub_info: Uint8Array, priv_info: Uint8Array);
/**
* Returns a copy of `apu'
* @returns {Uint8Array}
*/
  apu(): Uint8Array;
/**
* Returns a copy of `apv'
* @returns {Uint8Array}
*/
  apv(): Uint8Array;
/**
* Returns a copy of `pubInfo'
* @returns {Uint8Array}
*/
  pubInfo(): Uint8Array;
/**
* Returns a copy of `privInfo'
* @returns {Uint8Array}
*/
  privInfo(): Uint8Array;
/**
* Serializes `AgreementInfo` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `AgreementInfo` from a JSON object.
* @param {any} json_value
* @returns {AgreementInfo}
*/
  static fromJSON(json_value: any): AgreementInfo;
}
/**
*/
export class AutoSave {
  free(): void;
/**
* Never save.
* @returns {AutoSave}
*/
  static never(): AutoSave;
/**
* Save after every action.
* @returns {AutoSave}
*/
  static every(): AutoSave;
/**
* Save after every N actions.
* @param {number} number_of_actions
* @returns {AutoSave}
*/
  static batch(number_of_actions: number): AutoSave;
/**
* Serializes `AutoSave` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `AutoSave` from a JSON object.
* @param {any} json_value
* @returns {AutoSave}
*/
  static fromJSON(json_value: any): AutoSave;
}
/**
* Supported algorithms used to determine and potentially encrypt the content encryption key (CEK).
*/
export class CekAlgorithm {
  free(): void;
/**
* Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.
* @param {AgreementInfo} agreement
* @returns {CekAlgorithm}
*/
  static EcdhEs(agreement: AgreementInfo): CekAlgorithm;
/**
* Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.
* @param {AgreementInfo} agreement
* @returns {CekAlgorithm}
*/
  static EcdhEsA256Kw(agreement: AgreementInfo): CekAlgorithm;
/**
* Serializes `CekAlgorithm` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `CekAlgorithm` from a JSON object.
* @param {any} json_value
* @returns {CekAlgorithm}
*/
  static fromJSON(json_value: any): CekAlgorithm;
}
/**
*/
export class ChainState {
  free(): void;
/**
* Serializes a `ChainState` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a JSON object as `ChainState`.
* @param {any} json_value
* @returns {ChainState}
*/
  static fromJSON(json_value: any): ChainState;
}
/**
*/
export class Client {
  free(): void;
/**
* Creates a new `Client` with default settings.
*/
  constructor();
/**
* Creates a new `Client` with the given settings.
* @param {IClientConfig} config
* @returns {Promise<Client>}
*/
  static fromConfig(config: IClientConfig): Promise<Client>;
/**
* Returns the `Client` Tangle network.
* @returns {Network}
*/
  network(): Network;
/**
* Publishes a {@link Document} to the Tangle.
* @param {Document} document
* @returns {Promise<Receipt>}
*/
  publishDocument(document: Document): Promise<Receipt>;
/**
* Publishes a `DiffMessage` to the Tangle.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {string} message_id
* @param {DiffMessage} diff
* @returns {Promise<Receipt>}
*/
  publishDiff(message_id: string, diff: DiffMessage): Promise<Receipt>;
/**
* Publishes arbitrary JSON data to the specified index on the Tangle.
* @param {string} index
* @param {any} data
* @returns {Promise<Receipt>}
*/
  publishJSON(index: string, data: any): Promise<Receipt>;
/**
* Publishes arbitrary JSON data to the specified index on the Tangle.
* Retries (promotes or reattaches) the message until it’s included (referenced by a milestone).
* Default interval is 5 seconds and max attempts is 40.
* @param {string} index
* @param {any} data
* @param {number | undefined} interval
* @param {number | undefined} max_attempts
* @returns {Promise<any>}
*/
  publishJsonWithRetry(index: string, data: any, interval?: number, max_attempts?: number): Promise<any>;
/**
* Checks if a message is confirmed by a milestone.
* @param {string} messageId
* @returns {Promise<boolean>}
*/
  isMessageIncluded(messageId: string): Promise<boolean>;
/**
* Fetch the DID document specified by the given `DID`.
* @param {DID | string} did
* @returns {Promise<ResolvedDocument>}
*/
  resolve(did: DID | string): Promise<ResolvedDocument>;
/**
* Returns the message history of the given DID.
* @param {DID | string} did
* @returns {Promise<DocumentHistory>}
*/
  resolveHistory(did: DID | string): Promise<DocumentHistory>;
/**
* Returns the `DiffChainHistory` of a diff chain starting from a document on the
* integration chain.
*
* NOTE: the document must have been published to the tangle and have a valid message id and
* capability invocation method.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {ResolvedDocument} document
* @returns {Promise<DiffChainHistory>}
*/
  resolveDiffHistory(document: ResolvedDocument): Promise<DiffChainHistory>;
}
/**
*/
export class Credential {
  free(): void;
/**
* Returns the base JSON-LD context.
* @returns {string}
*/
  static BaseContext(): string;
/**
* Returns the base type.
* @returns {string}
*/
  static BaseType(): string;
/**
* Constructs a new `Credential`.
* @param {ICredential} values
*/
  constructor(values: ICredential);
/**
* Returns a copy of the JSON-LD context(s) applicable to the `Credential`.
* @returns {Array<string | Record<string, any>>}
*/
  context(): Array<string | Record<string, any>>;
/**
* Returns a copy of the unique `URI` identifying the `Credential` .
* @returns {string | undefined}
*/
  id(): string | undefined;
/**
* Returns a copy of the URIs defining the type of the `Credential`.
* @returns {Array<string>}
*/
  type(): Array<string>;
/**
* Returns a copy of the `Credential` subject(s).
* @returns {Array<Subject>}
*/
  credentialSubject(): Array<Subject>;
/**
* Returns a copy of the issuer of the `Credential`.
* @returns {string | Issuer}
*/
  issuer(): string | Issuer;
/**
* Returns a copy of the timestamp of when the `Credential` becomes valid.
* @returns {Timestamp}
*/
  issuanceDate(): Timestamp;
/**
* Returns a copy of the timestamp of when the `Credential` should no longer be considered valid.
* @returns {Timestamp | undefined}
*/
  expirationDate(): Timestamp | undefined;
/**
* Returns a copy of the information used to determine the current status of the `Credential`.
* @returns {Array<Status>}
*/
  credentialStatus(): Array<Status>;
/**
* Returns a copy of the information used to assist in the enforcement of a specific `Credential` structure.
* @returns {Array<Schema>}
*/
  credentialSchema(): Array<Schema>;
/**
* Returns a copy of the service(s) used to refresh an expired `Credential`.
* @returns {Array<RefreshService>}
*/
  refreshService(): Array<RefreshService>;
/**
* Returns a copy of the terms-of-use specified by the `Credential` issuer.
* @returns {Array<Policy>}
*/
  termsOfUse(): Array<Policy>;
/**
* Returns a copy of the human-readable evidence used to support the claims within the `Credential`.
* @returns {Array<Evidence>}
*/
  evidence(): Array<Evidence>;
/**
* Returns whether or not the `Credential` must only be contained within a {@link Presentation}
* with a proof issued from the `Credential` subject.
* @returns {boolean | undefined}
*/
  nonTransferable(): boolean | undefined;
/**
* Returns a copy of the proof used to verify the `Credential`.
* @returns {Proof | undefined}
*/
  proof(): Proof | undefined;
/**
* Returns a copy of the miscellaneous properties on the `Credential`.
* @returns {Map<string, any>}
*/
  properties(): Map<string, any>;
/**
* Serializes a `Credential` to a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Credential` from a JSON object.
* @param {any} json
* @returns {Credential}
*/
  static fromJSON(json: any): Credential;
/**
* Deep clones the object.
* @returns {Credential}
*/
  clone(): Credential;
}
/**
* Options to declare validation criteria when validating credentials.
*/
export class CredentialValidationOptions {
  free(): void;
/**
* Creates a new `CredentialValidationOptions` from the given fields.
*
* Throws an error if any of the options are invalid.
* @param {ICredentialValidationOptions} options
*/
  constructor(options: ICredentialValidationOptions);
/**
* Creates a new `CredentialValidationOptions` with defaults.
* @returns {CredentialValidationOptions}
*/
  static default(): CredentialValidationOptions;
/**
* Serializes a `CredentialValidationOptions` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `CredentialValidationOptions` from a JSON object.
* @param {any} json
* @returns {CredentialValidationOptions}
*/
  static fromJSON(json: any): CredentialValidationOptions;
/**
* Deep clones the object.
* @returns {CredentialValidationOptions}
*/
  clone(): CredentialValidationOptions;
}
/**
*/
export class CredentialValidator {
  free(): void;
/**
* Validates a `Credential`.
*
* The following properties are validated according to `options`:
* - the issuer's signature,
* - the expiration date,
* - the issuance date,
* - the semantic structure.
*
* ### Warning
* The lack of an error returned from this method is in of itself not enough to conclude that the credential can be
* trusted. This section contains more information on additional checks that should be carried out before and after
* calling this method.
*
* #### The state of the issuer's DID Document
* The caller must ensure that `issuer` represents an up-to-date DID Document. The convenience method
* `Resolver::resolveCredentialIssuer` can help extract the latest available state of the issuer's DID Document.
*
* #### Properties that are not validated
*  There are many properties defined in [The Verifiable Credentials Data Model](https://www.w3.org/TR/vc-data-model/) that are **not** validated, such as:
* `credentialStatus`, `type`, `credentialSchema`, `refreshService`, **and more**.
* These should be manually checked after validation, according to your requirements.
*
* ### Errors
* An error is returned whenever a validated condition is not satisfied.
* @param {Credential} credential
* @param {Document | ResolvedDocument} issuer
* @param {CredentialValidationOptions} options
* @param {number} fail_fast
*/
  static validate(credential: Credential, issuer: Document | ResolvedDocument, options: CredentialValidationOptions, fail_fast: number): void;
/**
* Validates the semantic structure of the `Credential`.
*
* ### Warning
* This does not validate against the credential's schema nor the structure of the subject claims.
* @param {Credential} credential
*/
  static checkStructure(credential: Credential): void;
/**
* Validate that the credential expires on or after the specified timestamp.
* @param {Credential} credential
* @param {Timestamp} timestamp
*/
  static checkExpiresOnOrAfter(credential: Credential, timestamp: Timestamp): void;
/**
* Validate that the credential is issued on or before the specified timestamp.
* @param {Credential} credential
* @param {Timestamp} timestamp
*/
  static checkIssuedOnOrBefore(credential: Credential, timestamp: Timestamp): void;
/**
* Verify the signature using the DID Document of a trusted issuer.
*
* # Warning
* The caller must ensure that the DID Documents of the trusted issuers are up-to-date.
* ### Errors
* This method immediately returns an error if
* the credential issuer' url cannot be parsed to a DID belonging to one of the trusted issuers. Otherwise an attempt
* to verify the credential's signature will be made and an error is returned upon failure.
* @param {Credential} credential
* @param {Array<Document> | Array<ResolvedDocument>} trusted_issuers
* @param {VerifierOptions} options
*/
  static verifySignature(credential: Credential, trusted_issuers: Array<Document> | Array<ResolvedDocument>, options: VerifierOptions): void;
/**
* Validate that the relationship between the `holder` and the credential subjects is in accordance with
* `relationship`. The `holder_url` parameter is expected to be the URL of the holder.
* @param {Credential} credential
* @param {string} holder_url
* @param {number} relationship
*/
  static check_subject_holder_relationship(credential: Credential, holder_url: string, relationship: number): void;
/**
* Checks whether the credential status has been revoked.
*
* Only supports `BitmapRevocation2022`.
* @param {Credential} credential
* @param {Array<Document> | Array<ResolvedDocument>} trustedIssuers
* @param {number} statusCheck
*/
  static checkStatus(credential: Credential, trustedIssuers: Array<Document> | Array<ResolvedDocument>, statusCheck: number): void;
}
/**
* @typicalname did
*/
export class DID {
  free(): void;
/**
* Creates a new `DID` from a public key.
* @param {Uint8Array} public_key
* @param {string | undefined} network
*/
  constructor(public_key: Uint8Array, network?: string);
/**
* Parses a `DID` from the input string.
* @param {string} input
* @returns {DID}
*/
  static parse(input: string): DID;
/**
* Returns the IOTA tangle network of the `DID`.
* @returns {Network}
*/
  network(): Network;
/**
* Returns a copy of the unique tag of the `DID`.
* @returns {string}
*/
  tag(): string;
/**
* Construct a new `DIDUrl` by joining with a relative DID Url string.
* @param {string} segment
* @returns {DIDUrl}
*/
  join(segment: string): DIDUrl;
/**
* Clones the `DID` into a `DIDUrl`.
* @returns {DIDUrl}
*/
  toUrl(): DIDUrl;
/**
* Converts the `DID` into a `DIDUrl`.
* @returns {DIDUrl}
*/
  intoUrl(): DIDUrl;
/**
* Returns the `DID` as a string.
* @returns {string}
*/
  toString(): string;
/**
* Deserializes a JSON object as `DID`.
* @param {any} json_value
* @returns {DID}
*/
  static fromJSON(json_value: any): DID;
/**
* Serializes a `DID` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deep clones the object.
* @returns {DID}
*/
  clone(): DID;
/**
* Returns the IOTA tangle network of the `DID`.
*/
  readonly networkName: string;
}
/**
* @typicalname didUrl
*/
export class DIDUrl {
  free(): void;
/**
* Parses a `DIDUrl` from the input string.
* @param {string} input
* @returns {DIDUrl}
*/
  static parse(input: string): DIDUrl;
/**
* Return a copy of the `DID` section of the `DIDUrl`.
* @returns {DID}
*/
  did(): DID;
/**
* Return a copy of the relative DID Url as a string, including only the path, query, and fragment.
* @returns {string}
*/
  urlStr(): string;
/**
* Returns a copy of the `DIDUrl` method fragment, if any. Excludes the leading '#'.
* @returns {string | undefined}
*/
  fragment(): string | undefined;
/**
* Sets the `fragment` component of the `DIDUrl`.
* @param {string | undefined} value
*/
  setFragment(value?: string): void;
/**
* Returns a copy of the `DIDUrl` path.
* @returns {string | undefined}
*/
  path(): string | undefined;
/**
* Sets the `path` component of the `DIDUrl`.
* @param {string | undefined} value
*/
  setPath(value?: string): void;
/**
* Returns a copy of the `DIDUrl` method query, if any. Excludes the leading '?'.
* @returns {string | undefined}
*/
  query(): string | undefined;
/**
* Sets the `query` component of the `DIDUrl`.
* @param {string | undefined} value
*/
  setQuery(value?: string): void;
/**
* Append a string representing a path, query, and/or fragment, returning a new `DIDUrl`.
*
* Must begin with a valid delimiter character: '/', '?', '#'. Overwrites the existing URL
* segment and any following segments in order of path, query, then fragment.
*
* I.e.
* - joining a path will clear the query and fragment.
* - joining a query will clear the fragment.
* - joining a fragment will only overwrite the fragment.
* @param {string} segment
* @returns {DIDUrl}
*/
  join(segment: string): DIDUrl;
/**
* Returns the `DIDUrl` as a string.
* @returns {string}
*/
  toString(): string;
/**
* Serializes a `DIDUrl` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deep clones the object.
* @returns {DIDUrl}
*/
  clone(): DIDUrl;
}
/**
* @deprecated since 0.5.0, diff chain features are slated for removal.
*/
export class DiffChainHistory {
  free(): void;
/**
* Returns an `Array` of the diff chain `DiffMessages`.
*
* NOTE: this clones the field.
* @returns {Array<DiffMessage>}
*/
  chainData(): Array<DiffMessage>;
/**
* Returns an `Array` of `MessageIds` as strings.
*
* NOTE: this clones the field.
* @returns {Array<string>}
*/
  spam(): Array<string>;
/**
* Serializes as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes from a JSON object.
* @param {any} json
* @returns {DiffChainHistory}
*/
  static fromJSON(json: any): DiffChainHistory;
}
/**
* Defines the difference between two DID `Document`s' JSON representations.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
*/
export class DiffMessage {
  free(): void;
/**
* Returns the DID of the associated DID Document.
*
* NOTE: clones the data.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {DID}
*/
  id(): DID;
/**
* Returns a copy of the DID of the associated DID Document.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {DID}
*/
  did(): DID;
/**
* Returns a copy of the raw contents of the DID Document diff as a JSON string.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {string}
*/
  diff(): string;
/**
* Returns a copy of the message_id of the DID Document diff.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {string}
*/
  messageId(): string;
/**
* Sets the message_id of the DID Document diff.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {string} message_id
*/
  setMessageId(message_id: string): void;
/**
* Returns a copy of the Tangle message id of the previous DID Document diff.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {string}
*/
  previousMessageId(): string;
/**
* Sets the Tangle message id of the previous DID Document diff.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {string} message_id
*/
  setPreviousMessageId(message_id: string): void;
/**
* Returns a copy of the proof.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {Proof | undefined}
*/
  proof(): Proof | undefined;
/**
* Returns a new DID Document which is the result of merging `self`
* with the given Document.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {Document} document
* @returns {Document}
*/
  merge(document: Document): Document;
/**
* Serializes a `DiffMessage` as a JSON object.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `DiffMessage` from a JSON object.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {any} json
* @returns {DiffMessage}
*/
  static fromJSON(json: any): DiffMessage;
/**
* Deep clones the object.
* @returns {DiffMessage}
*/
  clone(): DiffMessage;
}
/**
*/
export class Document {
  free(): void;
/**
* Creates a new DID Document from the given `KeyPair`, network, and verification method
* fragment name.
*
* The DID Document will be pre-populated with a single verification method
* derived from the provided `KeyPair` embedded as a capability invocation
* verification relationship. This method will have the DID URL fragment
* `#sign-0` by default and can be easily retrieved with `Document::defaultSigningMethod`.
*
* NOTE: the generated document is unsigned, see `Document::signSelf`.
*
* Arguments:
*
* * keypair: the initial verification method is derived from the public key with this keypair.
* * network: Tangle network to use for the DID, default `Network::mainnet`.
* * fragment: name of the initial verification method, default "sign-0".
* @param {KeyPair} keypair
* @param {string | undefined} network
* @param {string | undefined} fragment
*/
  constructor(keypair: KeyPair, network?: string, fragment?: string);
/**
* Creates a new DID Document from the given `VerificationMethod`.
*
* NOTE: the generated document is unsigned, see `Document::signSelf`.
* @param {VerificationMethod} method
* @returns {Document}
*/
  static fromVerificationMethod(method: VerificationMethod): Document;
/**
* Returns whether the given {@link MethodType} can be used to sign document updates.
* @param {MethodType} method_type
* @returns {boolean}
*/
  static isSigningMethodType(method_type: MethodType): boolean;
/**
* Returns a copy of the DID Document `id`.
* @returns {DID}
*/
  id(): DID;
/**
* Sets the controllers of the DID Document.
*
* Note: Duplicates will be ignored.
* Use `null` to remove all controllers.
* @param {DID | DID[] | null} controllers
*/
  setController(controllers: DID | DID[] | null): void;
/**
* Returns a list of document controllers.
* @returns {DID[]}
*/
  controller(): DID[];
/**
* Sets the `alsoKnownAs` property in the DID document.
* @param {string | string[] | null} urls
*/
  setAlsoKnownAs(urls: string | string[] | null): void;
/**
* Returns a set of the document's `alsoKnownAs`.
* @returns {Array<string>}
*/
  alsoKnownAs(): Array<string>;
/**
* Adds a custom property to the DID Document.
* If the value is set to `null`, the custom property will be removed.
*
* ### WARNING
* This method can overwrite existing properties like `id` and result in an invalid document.
* @param {string} key
* @param {any} value
*/
  setPropertyUnchecked(key: string, value: any): void;
/**
* Returns a copy of the custom DID Document properties.
* @returns {Map<string, any>}
*/
  properties(): Map<string, any>;
/**
* Return a set of all {@link Service Services} in the document.
* @returns {Service[]}
*/
  service(): Service[];
/**
* Add a new {@link Service} to the document.
*
* Returns `true` if the service was added.
* @param {Service} service
* @returns {boolean}
*/
  insertService(service: Service): boolean;
/**
* Remove a {@link Service} identified by the given {@link DIDUrl} from the document.
*
* Returns `true` if a service was removed.
* @param {DIDUrl} did
* @returns {boolean}
*/
  removeService(did: DIDUrl): boolean;
/**
* Returns a list of all {@link VerificationMethod} in the DID Document.
* @returns {VerificationMethod[]}
*/
  methods(): VerificationMethod[];
/**
* Adds a new Verification Method to the DID Document.
* @param {VerificationMethod} method
* @param {MethodScope} scope
*/
  insertMethod(method: VerificationMethod, scope: MethodScope): void;
/**
* Removes all references to the specified Verification Method.
* @param {DIDUrl} did
*/
  removeMethod(did: DIDUrl): void;
/**
* Returns a copy of the first `VerificationMethod` with a capability invocation relationship
* capable of signing this DID document.
*
* Throws an error if no signing method is present.
* @returns {VerificationMethod}
*/
  defaultSigningMethod(): VerificationMethod;
/**
* Returns a copy of the first `VerificationMethod` with an `id` property
* matching the provided `query`.
*
* Throws an error if the method is not found.
* @param {DIDUrl | string} query
* @param {MethodScope | undefined} scope
* @returns {VerificationMethod | undefined}
*/
  resolveMethod(query: DIDUrl | string, scope?: MethodScope): VerificationMethod | undefined;
/**
* Attempts to resolve the given method query into a method capable of signing a document update.
* @param {DIDUrl | string} query
* @returns {VerificationMethod}
*/
  resolveSigningMethod(query: DIDUrl | string): VerificationMethod;
/**
* Attaches the relationship to the given method, if the method exists.
*
* Note: The method needs to be in the set of verification methods,
* so it cannot be an embedded one.
* @param {DIDUrl} did_url
* @param {number} relationship
* @returns {boolean}
*/
  attachMethodRelationship(did_url: DIDUrl, relationship: number): boolean;
/**
* Detaches the given relationship from the given method, if the method exists.
* @param {DIDUrl} did_url
* @param {number} relationship
* @returns {boolean}
*/
  detachMethodRelationship(did_url: DIDUrl, relationship: number): boolean;
/**
* Signs the DID document with the verification method specified by `method_query`.
* The `method_query` may be the full `DIDUrl` of the method or just its fragment,
* e.g. "#sign-0".
*
* NOTE: does not validate whether the private key of the given `key_pair` corresponds to the
* verification method. See `Document::verifySelfSigned`.
* @param {KeyPair} key_pair
* @param {DIDUrl | string} method_query
*/
  signSelf(key_pair: KeyPair, method_query: DIDUrl | string): void;
/**
* Signs another DID document using the verification method specified by `method_query`.
* The `method_query` may be the full `DIDUrl` of the method or just its fragment,
* e.g. "#sign-0".
*
* `Document.signSelf` should be used in general, this throws an error if trying to operate
* on the same document. This is intended for signing updates to a document where a sole
* capability invocation method is rotated or replaced entirely.
*
* NOTE: does not validate whether the private key of the given `key_pair` corresponds to the
* verification method. See {@link Document.verifyDocument}.
* @param {Document} document
* @param {KeyPair} key_pair
* @param {DIDUrl | string} method_query
*/
  signDocument(document: Document, key_pair: KeyPair, method_query: DIDUrl | string): void;
/**
* Creates a signature for the given `Credential` with the specified DID Document
* Verification Method.
* @param {Credential} credential
* @param {Uint8Array} privateKey
* @param {DIDUrl | string} methodQuery
* @param {ProofOptions} options
* @returns {Credential}
*/
  signCredential(credential: Credential, privateKey: Uint8Array, methodQuery: DIDUrl | string, options: ProofOptions): Credential;
/**
* Creates a signature for the given `Presentation` with the specified DID Document
* Verification Method.
* @param {Presentation} presentation
* @param {Uint8Array} privateKey
* @param {DIDUrl | string} methodQuery
* @param {ProofOptions} options
* @returns {Presentation}
*/
  signPresentation(presentation: Presentation, privateKey: Uint8Array, methodQuery: DIDUrl | string, options: ProofOptions): Presentation;
/**
* Creates a signature for the given `data` with the specified DID Document
* Verification Method.
*
* NOTE: use `signSelf` or `signDocument` for DID Documents.
* @param {any} data
* @param {Uint8Array} privateKey
* @param {DIDUrl | string} methodQuery
* @param {ProofOptions} options
* @returns {any}
*/
  signData(data: any, privateKey: Uint8Array, methodQuery: DIDUrl | string, options: ProofOptions): any;
/**
* Verifies the authenticity of `data` using the target verification method.
* @param {any} data
* @param {VerifierOptions} options
* @returns {boolean}
*/
  verifyData(data: any, options: VerifierOptions): boolean;
/**
* Verifies that the signature on the DID document `signed` was generated by a valid method from
* this DID document.
*
* # Errors
*
* Fails if:
* - The signature proof section is missing in the `signed` document.
* - The method is not found in this document.
* - An unsupported verification method is used.
* - The signature verification operation fails.
* @param {Document} signed
*/
  verifyDocument(signed: Document): void;
/**
* Verifies whether `document` is a valid root DID document according to the IOTA DID method
* specification.
*
* It must be signed using a verification method with a public key whose BLAKE2b-256 hash matches
* the DID tag.
* @param {Document} document
*/
  static verifyRootDocument(document: Document): void;
/**
* Generate a `DiffMessage` between two DID Documents and sign it using the specified
* `key` and `method`.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {Document} other
* @param {string} message_id
* @param {KeyPair} key
* @param {DIDUrl | string} method_query
* @returns {DiffMessage}
*/
  diff(other: Document, message_id: string, key: KeyPair, method_query: DIDUrl | string): DiffMessage;
/**
* Verifies the signature of the `diff` was created using a capability invocation method
* in this DID Document.
*
* # Errors
*
* Fails if an unsupported verification method is used or the verification operation fails.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {DiffMessage} diff
*/
  verifyDiff(diff: DiffMessage): void;
/**
* Verifies a `DiffMessage` signature and attempts to merge the changes into `self`.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {DiffMessage} diff
*/
  mergeDiff(diff: DiffMessage): void;
/**
* Returns the Tangle index of the integration chain for this DID.
*
* This is simply the tag segment of the `DID`.
* E.g.
* For a document with DID: did:iota:1234567890abcdefghijklmnopqrstuvxyzABCDEFGHI,
* `doc.integration_index()` == "1234567890abcdefghijklmnopqrstuvxyzABCDEFGHI"
* @returns {string}
*/
  integrationIndex(): string;
/**
* Returns the Tangle index of the DID diff chain. This should only be called on documents
* published on the integration chain.
*
* This is the Base58-btc encoded SHA-256 digest of the hex-encoded message id.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {string} message_id
* @returns {string}
*/
  static diffIndex(message_id: string): string;
/**
* Returns a copy of the metadata associated with this document.
*
* NOTE: Copies all the metadata. See also `metadataCreated`, `metadataUpdated`,
* `metadataPreviousMessageId`, `metadataProof` if only a subset of the metadata required.
* @returns {DocumentMetadata}
*/
  metadata(): DocumentMetadata;
/**
* Returns a copy of the timestamp of when the DID document was created.
* @returns {Timestamp | undefined}
*/
  metadataCreated(): Timestamp | undefined;
/**
* Sets the timestamp of when the DID document was created.
* @param {Timestamp | undefined} timestamp
*/
  setMetadataCreated(timestamp: Timestamp | undefined): void;
/**
* Returns a copy of the timestamp of the last DID document update.
* @returns {Timestamp | undefined}
*/
  metadataUpdated(): Timestamp | undefined;
/**
* Sets the timestamp of the last DID document update.
* @param {Timestamp | undefined} timestamp
*/
  setMetadataUpdated(timestamp: Timestamp | undefined): void;
/**
* Returns a copy of the previous integration chain message id.
* @returns {string}
*/
  metadataPreviousMessageId(): string;
/**
* Sets the previous integration chain message id.
* @param {string} value
*/
  setMetadataPreviousMessageId(value: string): void;
/**
* Returns a copy of the proof.
* @returns {Proof | undefined}
*/
  proof(): Proof | undefined;
/**
* If the document has a `RevocationBitmap` service identified by `fragment`,
* revoke all credentials with a revocationBitmapIndex in `credentialIndices`.
* @param {string} fragment
* @param {number | number[]} credentialIndices
*/
  revokeCredentials(fragment: string, credentialIndices: number | number[]): void;
/**
* If the document has a `RevocationBitmap` service identified by `fragment`,
* unrevoke all credentials with a revocationBitmapIndex in `credentialIndices`.
* @param {string} fragment
* @param {number | number[]} credentialIndices
*/
  unrevokeCredentials(fragment: string, credentialIndices: number | number[]): void;
/**
* Serializes a `Document` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Document` from a JSON object.
* @param {any} json
* @returns {Document}
*/
  static fromJSON(json: any): Document;
/**
* Deep clones the object.
* @returns {Document}
*/
  clone(): Document;
}
/**
* A DID Document's history and current state.
*/
export class DocumentHistory {
  free(): void;
/**
* Returns an `Array` of integration chain `Documents`.
*
* NOTE: clones the data.
* @returns {Array<ResolvedDocument>}
*/
  integrationChainData(): Array<ResolvedDocument>;
/**
* Returns an `Array` of message id strings for "spam" messages on the same index
* as the integration chain.
*
* NOTE: clones the data.
* @returns {Array<string>}
*/
  integrationChainSpam(): Array<string>;
/**
* Returns an `Array` of diff chain `DiffMessages`.
*
* NOTE: clones the data.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {Array<DiffMessage>}
*/
  diffChainData(): Array<DiffMessage>;
/**
* Returns an `Array` of message id strings for "spam" messages on the same index
* as the diff chain.
*
* NOTE: clones the data.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {Array<string>}
*/
  diffChainSpam(): Array<string>;
/**
* Serializes `DocumentHistory` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `DocumentHistory` from a JSON object.
* @param {any} json
* @returns {DocumentHistory}
*/
  static fromJSON(json: any): DocumentHistory;
/**
* Deep clones the object.
* @returns {DocumentHistory}
*/
  clone(): DocumentHistory;
}
/**
* Additional attributes related to an IOTA DID Document.
*/
export class DocumentMetadata {
  free(): void;
/**
* Returns a copy of the timestamp of when the DID document was created.
* @returns {Timestamp | undefined}
*/
  created(): Timestamp | undefined;
/**
* Returns a copy of the timestamp of the last DID document update.
* @returns {Timestamp | undefined}
*/
  updated(): Timestamp | undefined;
/**
* Deep clones the object.
* @returns {DocumentMetadata}
*/
  clone(): DocumentMetadata;
/**
*/
  readonly previousMessageId: string;
}
/**
* A span of time.
*/
export class Duration {
  free(): void;
/**
* Create a new `Duration` with the given number of seconds.
* @param {number} seconds
* @returns {Duration}
*/
  static seconds(seconds: number): Duration;
/**
* Create a new `Duration` with the given number of minutes.
* @param {number} minutes
* @returns {Duration}
*/
  static minutes(minutes: number): Duration;
/**
* Create a new `Duration` with the given number of hours.
* @param {number} hours
* @returns {Duration}
*/
  static hours(hours: number): Duration;
/**
* Create a new `Duration` with the given number of days.
* @param {number} days
* @returns {Duration}
*/
  static days(days: number): Duration;
/**
* Create a new `Duration` with the given number of weeks.
* @param {number} weeks
* @returns {Duration}
*/
  static weeks(weeks: number): Duration;
/**
* Serializes a `Duration` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Duration` from a JSON object.
* @param {any} json
* @returns {Duration}
*/
  static fromJSON(json: any): Duration;
}
/**
*/
export class Ed25519 {
  free(): void;
/**
* Length in bytes of an Ed25519 private key.
* @returns {number}
*/
  static PRIVATE_KEY_LENGTH(): number;
/**
* Length in bytes of an Ed25519 public key.
* @returns {number}
*/
  static PUBLIC_KEY_LENGTH(): number;
/**
* Length in bytes of an Ed25519 signature.
* @returns {number}
*/
  static SIGNATURE_LENGTH(): number;
/**
* Computes an EdDSA signature using an Ed25519 private key.
*
* NOTE: this differs from {@link Document.signData} which uses JCS
* to canonicalize JSON messages.
*
* The private key must be a 32-byte seed in compliance with [RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032#section-3.2).
* Other implementations often use another format. See [this blog post](https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/) for further explanation.
* @param {Uint8Array} message
* @param {Uint8Array} privateKey
* @returns {Uint8Array}
*/
  static sign(message: Uint8Array, privateKey: Uint8Array): Uint8Array;
/**
* Verifies an EdDSA signature against an Ed25519 public key.
*
* NOTE: this differs from {@link Document.verifyData} which uses JCS
* to canonicalize JSON messages.
* @param {Uint8Array} message
* @param {Uint8Array} signature
* @param {Uint8Array} publicKey
*/
  static verify(message: Uint8Array, signature: Uint8Array, publicKey: Uint8Array): void;
}
/**
* The structure returned after encrypting data
*/
export class EncryptedData {
  free(): void;
/**
* Returns a copy of the nonce
* @returns {Uint8Array}
*/
  nonce(): Uint8Array;
/**
* Returns a copy of the associated data
* @returns {Uint8Array}
*/
  associatedData(): Uint8Array;
/**
* Returns a copy of the ciphertext
* @returns {Uint8Array}
*/
  ciphertext(): Uint8Array;
/**
* Returns a copy of the tag
* @returns {Uint8Array}
*/
  tag(): Uint8Array;
/**
* Serializes `EncryptedData` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `EncryptedData` from a JSON object.
* @param {any} json_value
* @returns {EncryptedData}
*/
  static fromJSON(json_value: any): EncryptedData;
}
/**
* Supported content encryption algorithms.
*/
export class EncryptionAlgorithm {
  free(): void;
/**
* AES GCM using 256-bit key.
* @returns {EncryptionAlgorithm}
*/
  static A256GCM(): EncryptionAlgorithm;
/**
* Returns the length of the cipher's key.
* @returns {number}
*/
  keyLength(): number;
/**
* Serializes `EncryptionAlgorithm` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `EncryptionAlgorithm` from a JSON object.
* @param {any} json_value
* @returns {EncryptionAlgorithm}
*/
  static fromJSON(json_value: any): EncryptionAlgorithm;
}
/**
*/
export class ExplorerUrl {
  free(): void;
/**
* Constructs a new Tangle explorer URL from a string.
*
* Use `ExplorerUrl::mainnet` or `ExplorerUrl::devnet` unless using a private Tangle
* or local explorer.
* @param {string} url
* @returns {ExplorerUrl}
*/
  static parse(url: string): ExplorerUrl;
/**
* Returns the Tangle explorer URL for the mainnet.
* @returns {ExplorerUrl}
*/
  static mainnet(): ExplorerUrl;
/**
* Returns the Tangle explorer URL for the devnet.
* @returns {ExplorerUrl}
*/
  static devnet(): ExplorerUrl;
/**
* Returns the web explorer URL of the given `message_id`.
*
* E.g. https://explorer.iota.org/mainnet/message/{message_id}
* @param {string} message_id
* @returns {string}
*/
  messageUrl(message_id: string): string;
/**
* Returns the web identity resolver URL for the given DID.
*
* E.g. https://explorer.iota.org/mainnet/identity-resolver/{did}
* @param {DID | string} did
* @returns {string}
*/
  resolverUrl(did: DID | string): string;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class IntegrationChainHistory {
  free(): void;
/**
* Returns an `Array` of the integration chain `Documents`.
*
* NOTE: this clones the field.
* @returns {Array<ResolvedDocument>}
*/
  chainData(): Array<ResolvedDocument>;
/**
* Returns an `Array` of `MessageIds` as strings.
*
* NOTE: this clones the field.
* @returns {Array<string>}
*/
  spam(): Array<string>;
/**
* Serializes as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes from a JSON object.
* @param {any} json
* @returns {IntegrationChainHistory}
*/
  static fromJSON(json: any): IntegrationChainHistory;
}
/**
* The storage location of a verification method key.
*
* A key is uniquely identified by the fragment and a hash of its public key.
* Importantly, the fragment alone is insufficient to represent the storage location.
* For example, when rotating a key, there will be two keys in storage for the
* same identity with the same fragment. The `key_hash` disambiguates the keys in
* situations like these.
*
* The string representation of that location can be obtained via `canonicalRepr`.
*/
export class KeyLocation {
  free(): void;
/**
* Create a location from a `KeyType`, the fragment of a verification method
* and the bytes of a public key.
* @param {number} keyType
* @param {string} fragment
* @param {Uint8Array} publicKey
*/
  constructor(keyType: number, fragment: string, publicKey: Uint8Array);
/**
* Obtain the location of a verification method's key in storage.
* @param {VerificationMethod} method
* @returns {KeyLocation}
*/
  static fromVerificationMethod(method: VerificationMethod): KeyLocation;
/**
* Returns the canonical string representation of the location.
*
* This should be used as the representation for storage keys.
* @returns {string}
*/
  canonical(): string;
/**
* Returns a copy of the key type of the key location.
* @returns {number}
*/
  keyType(): number;
/**
* Serializes `KeyLocation` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a JSON object into a `KeyLocation`.
* @param {any} json_value
* @returns {KeyLocation}
*/
  static fromJSON(json_value: any): KeyLocation;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class KeyPair {
  free(): void;
/**
* Generates a new `KeyPair` object.
* @param {number} type_
*/
  constructor(type_: number);
/**
* Parses a `KeyPair` object from the public/private keys.
* @param {number} type_
* @param {Uint8Array} public_key
* @param {Uint8Array} private_key
* @returns {KeyPair}
*/
  static fromKeys(type_: number, public_key: Uint8Array, private_key: Uint8Array): KeyPair;
/**
* Reconstructs a `KeyPair` from the bytes of a private key.
*
* The private key for `Ed25519` must be a 32-byte seed in compliance
* with [RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032#section-3.2).
* Other implementations often use another format. See [this blog post](https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/) for further explanation.
* @param {number} keyType
* @param {Uint8Array} privateKeyBytes
* @returns {KeyPair}
*/
  static tryFromPrivateKeyBytes(keyType: number, privateKeyBytes: Uint8Array): KeyPair;
/**
* Returns the `KeyType` of the `KeyPair` object.
* @returns {number}
*/
  type(): number;
/**
* Returns a copy of the public key as a `Uint8Array`.
* @returns {Uint8Array}
*/
  public(): Uint8Array;
/**
* Returns a copy of the private key as a `Uint8Array`.
* @returns {Uint8Array}
*/
  private(): Uint8Array;
/**
* Serializes a `KeyPair` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `KeyPair` object from a JSON object.
* @param {any} json
* @returns {KeyPair}
*/
  static fromJSON(json: any): KeyPair;
/**
* Deep clones the object.
* @returns {KeyPair}
*/
  clone(): KeyPair;
}
/**
*/
export class MethodContent {
  free(): void;
/**
* Generate and store a new Ed25519 keypair for a new `Ed25519VerificationKey2018` method.
* @returns {MethodContent}
*/
  static GenerateEd25519(): MethodContent;
/**
* Store an existing Ed25519 private key and derive a public key from it for a new
* `Ed25519VerificationKey2018` method.
* @param {Uint8Array} privateKey
* @returns {MethodContent}
*/
  static PrivateEd25519(privateKey: Uint8Array): MethodContent;
/**
* Insert an existing Ed25519 public key into a new `Ed25519VerificationKey2018` method,
* without generating or storing a private key.
*
* NOTE: the method will be unable to be used to sign anything without a private key.
* @param {Uint8Array} publicKey
* @returns {MethodContent}
*/
  static PublicEd25519(publicKey: Uint8Array): MethodContent;
/**
* Generate and store a new X25519 keypair for a new `X25519KeyAgreementKey2019` method.
* @returns {MethodContent}
*/
  static GenerateX25519(): MethodContent;
/**
* Store an existing X25519 private key and derive a public key from it for a new
* `X25519KeyAgreementKey2019` method.
* @param {Uint8Array} privateKey
* @returns {MethodContent}
*/
  static PrivateX25519(privateKey: Uint8Array): MethodContent;
/**
* Insert an existing X25519 public key into a new `X25519KeyAgreementKey2019` method,
* without generating or storing a private key.
*
* NOTE: the method will be unable to be used for key exchange without a private key.
* @param {Uint8Array} publicKey
* @returns {MethodContent}
*/
  static PublicX25519(publicKey: Uint8Array): MethodContent;
/**
* Serializes `MethodContent` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes `MethodContent` from a JSON object.
* @param {any} json_value
* @returns {MethodContent}
*/
  static fromJSON(json_value: any): MethodContent;
}
/**
* Supported verification method data formats.
*/
export class MethodData {
  free(): void;
/**
* Creates a new `MethodData` variant with Base58-BTC encoded content.
* @param {Uint8Array} data
* @returns {MethodData}
*/
  static newBase58(data: Uint8Array): MethodData;
/**
* Creates a new `MethodData` variant with Multibase-encoded content.
* @param {Uint8Array} data
* @returns {MethodData}
*/
  static newMultibase(data: Uint8Array): MethodData;
/**
* Returns a `Uint8Array` containing the decoded bytes of the `MethodData`.
*
* This is generally a public key identified by a `MethodData` value.
*
* ### Errors
* Decoding can fail if `MethodData` has invalid content or cannot be
* represented as a vector of bytes.
* @returns {Uint8Array}
*/
  tryDecode(): Uint8Array;
/**
* Serializes a `MethodData` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `MethodData` object from a JSON object.
* @param {any} json
* @returns {MethodData}
*/
  static fromJSON(json: any): MethodData;
/**
* Deep clones the object.
* @returns {MethodData}
*/
  clone(): MethodData;
}
/**
* Supported verification method types.
*/
export class MethodScope {
  free(): void;
/**
* @returns {MethodScope}
*/
  static VerificationMethod(): MethodScope;
/**
* @returns {MethodScope}
*/
  static Authentication(): MethodScope;
/**
* @returns {MethodScope}
*/
  static AssertionMethod(): MethodScope;
/**
* @returns {MethodScope}
*/
  static KeyAgreement(): MethodScope;
/**
* @returns {MethodScope}
*/
  static CapabilityDelegation(): MethodScope;
/**
* @returns {MethodScope}
*/
  static CapabilityInvocation(): MethodScope;
/**
* Returns the `MethodScope` as a string.
* @returns {string}
*/
  toString(): string;
/**
* Serializes a `MethodScope` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `MethodScope` object from a JSON object.
* @param {any} json
* @returns {MethodScope}
*/
  static fromJSON(json: any): MethodScope;
/**
* Deep clones the object.
* @returns {MethodScope}
*/
  clone(): MethodScope;
}
/**
* Supported verification method types.
*/
export class MethodType {
  free(): void;
/**
* @returns {MethodType}
*/
  static Ed25519VerificationKey2018(): MethodType;
/**
* @returns {MethodType}
*/
  static X25519KeyAgreementKey2019(): MethodType;
/**
* Serializes a `MethodType` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `MethodType` object from a JSON object.
* @param {any} json
* @returns {MethodType}
*/
  static fromJSON(json: any): MethodType;
/**
* Returns the `MethodType` as a string.
* @returns {string}
*/
  toString(): string;
/**
* Deep clones the object.
* @returns {MethodType}
*/
  clone(): MethodType;
}
/**
*/
export class Network {
  free(): void;
/**
* Parses the provided string to a `Network`.
*
* Errors if the name is invalid.
* @param {string} name
* @returns {Network}
*/
  static tryFromName(name: string): Network;
/**
* @returns {Network}
*/
  static mainnet(): Network;
/**
* @returns {Network}
*/
  static devnet(): Network;
/**
* Returns a copy of the network name.
* @returns {string}
*/
  name(): string;
/**
* Returns a copy of the node URL of the Tangle network.
* @returns {string | undefined}
*/
  defaultNodeURL(): string | undefined;
/**
* @returns {string}
*/
  toString(): string;
/**
* Serializes a `Network` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Network` from a JSON object.
* @param {any} json
* @returns {Network}
*/
  static fromJSON(json: any): Network;
/**
* Deep clones the object.
* @returns {Network}
*/
  clone(): Network;
}
/**
*/
export class Presentation {
  free(): void;
/**
* Returns the base JSON-LD context.
* @returns {string}
*/
  static BaseContext(): string;
/**
* Returns the base type.
* @returns {string}
*/
  static BaseType(): string;
/**
* Constructs a new `Presentation`.
* @param {IPresentation} values
*/
  constructor(values: IPresentation);
/**
* Returns a copy of the JSON-LD context(s) applicable to the `Presentation`.
* @returns {Array<string | Record<string, any>>}
*/
  context(): Array<string | Record<string, any>>;
/**
* Returns a copy of the unique `URI` identifying the `Presentation`.
* @returns {string | undefined}
*/
  id(): string | undefined;
/**
* Returns a copy of the URIs defining the type of the `Presentation`.
* @returns {Array<string>}
*/
  type(): Array<string>;
/**
* Returns a copy of the {@link Credential}(s) expressing the claims of the `Presentation`.
* @returns {Array<Credential>}
*/
  verifiableCredential(): Array<Credential>;
/**
* Returns a copy of the URI of the entity that generated the `Presentation`.
* @returns {string | undefined}
*/
  holder(): string | undefined;
/**
* Returns a copy of the service(s) used to refresh an expired {@link Credential} in the `Presentation`.
* @returns {Array<RefreshService>}
*/
  refreshService(): Array<RefreshService>;
/**
* Returns a copy of the terms-of-use specified by the `Presentation` holder
* @returns {Array<Policy>}
*/
  termsOfUse(): Array<Policy>;
/**
* Returns a copy of the proof used to verify the `Presentation`.
* @returns {Proof | undefined}
*/
  proof(): Proof | undefined;
/**
* Returns a copy of the miscellaneous properties on the `Presentation`.
* @returns {Map<string, any>}
*/
  properties(): Map<string, any>;
/**
* Serializes a `Presentation` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Presentation` from a JSON object.
* @param {any} json
* @returns {Presentation}
*/
  static fromJSON(json: any): Presentation;
/**
* Deep clones the object.
* @returns {Presentation}
*/
  clone(): Presentation;
}
/**
* Options to declare validation criteria when validating presentation.
*/
export class PresentationValidationOptions {
  free(): void;
/**
* Creates a new `PresentationValidationOptions` from the given fields.
*
* Throws an error if any of the options are invalid.
* @param {IPresentationValidationOptions} options
*/
  constructor(options: IPresentationValidationOptions);
/**
* Creates a new `PresentationValidationOptions` with defaults.
* @returns {PresentationValidationOptions}
*/
  static default(): PresentationValidationOptions;
/**
* Serializes a `PresentationValidationOptions` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `PresentationValidationOptions` from a JSON object.
* @param {any} json
* @returns {PresentationValidationOptions}
*/
  static fromJSON(json: any): PresentationValidationOptions;
/**
* Deep clones the object.
* @returns {PresentationValidationOptions}
*/
  clone(): PresentationValidationOptions;
}
/**
*/
export class PresentationValidator {
  free(): void;
/**
* Validate a `Presentation`.
*
* The following properties are validated according to `options`:
* - the semantic structure of the presentation,
* - the holder's signature,
* - the relationship between the holder and the credential subjects,
* - the signatures and some properties of the constituent credentials (see
* `CredentialValidator::validate`).
*
* ### Warning
* The lack of an error returned from this method is in of itself not enough to conclude that the presentation can be
* trusted. This section contains more information on additional checks that should be carried out before and after
* calling this method.
*
* #### The state of the supplied DID Documents.
* The caller must ensure that the DID Documents in `holder` and `issuers` are up-to-date. The convenience methods
* `Resolver::resolve_presentation_holder` and `Resolver::resolve_presentation_issuers`
* can help extract the latest available states of these DID Documents.
*
* #### Properties that are not validated
*  There are many properties defined in [The Verifiable Credentials Data Model](https://www.w3.org/TR/vc-data-model/) that are **not** validated, such as:
* `credentialStatus`, `type`, `credentialSchema`, `refreshService`, **and more**.
* These should be manually checked after validation, according to your requirements.
*
* ### Errors
* An error is returned whenever a validated condition is not satisfied.
* @param {Presentation} presentation
* @param {Document | ResolvedDocument} holder
* @param {Array<Document> | Array<ResolvedDocument>} issuers
* @param {PresentationValidationOptions} options
* @param {number} fail_fast
*/
  static validate(presentation: Presentation, holder: Document | ResolvedDocument, issuers: Array<Document> | Array<ResolvedDocument>, options: PresentationValidationOptions, fail_fast: number): void;
/**
* Verify the presentation's signature using the resolved document of the holder.
*
* ### Warning
* The caller must ensure that the DID Document of the holder is up-to-date.
*
* ### Errors
* Fails if the `holder` does not match the `presentation`'s holder property.
* Fails if signature verification against the holder document fails.
* @param {Presentation} presentation
* @param {Document | ResolvedDocument} holder
* @param {VerifierOptions} options
*/
  static verifyPresentationSignature(presentation: Presentation, holder: Document | ResolvedDocument, options: VerifierOptions): void;
/**
* Validates the semantic structure of the `Presentation`.
* @param {Presentation} presentation
*/
  static checkStructure(presentation: Presentation): void;
}
/**
* A digital signature.
*
* For field definitions see: https://w3c-ccg.github.io/security-vocab/
*/
export class Proof {
  free(): void;
/**
* Returns a copy of the proof type.
* @returns {string}
*/
  type(): string;
/**
* Returns a copy of the proof value string.
* @returns {string}
*/
  value(): string;
/**
* Returns a copy of the identifier of the DID method used to create this proof.
* @returns {string}
*/
  verificationMethod(): string;
/**
* When the proof was generated.
* @returns {Timestamp | undefined}
*/
  created(): Timestamp | undefined;
/**
* When the proof expires.
* @returns {Timestamp | undefined}
*/
  expires(): Timestamp | undefined;
/**
* Challenge from a proof requester to mitigate replay attacks.
* @returns {string | undefined}
*/
  challenge(): string | undefined;
/**
* Domain for which a proof is valid to mitigate replay attacks.
* @returns {string | undefined}
*/
  domain(): string | undefined;
/**
* Purpose for which the proof was generated.
* @returns {ProofPurpose | undefined}
*/
  purpose(): ProofPurpose | undefined;
/**
* Serializes a `Proof` to a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Proof` from a JSON object.
* @param {any} json
* @returns {Proof}
*/
  static fromJSON(json: any): Proof;
/**
* Deep clones the object.
* @returns {Proof}
*/
  clone(): Proof;
}
/**
* Holds additional options for creating signatures.
* See `IProofOptions`.
*/
export class ProofOptions {
  free(): void;
/**
* Creates a new `ProofOptions` from the given fields.
*
* Throws an error if any of the options are invalid.
* @param {IProofOptions} options
*/
  constructor(options: IProofOptions);
/**
* Creates a new `ProofOptions` with default options.
* @returns {ProofOptions}
*/
  static default(): ProofOptions;
/**
* Deep clones the object.
* @returns {ProofOptions}
*/
  clone(): ProofOptions;
}
/**
* Associates a purpose with a {@link Proof}.
*
* See https://w3c-ccg.github.io/security-vocab/#proofPurpose
*/
export class ProofPurpose {
  free(): void;
/**
* Purpose is to assert a claim.
* See https://www.w3.org/TR/did-core/#assertion
* @returns {ProofPurpose}
*/
  static assertionMethod(): ProofPurpose;
/**
* Purpose is to authenticate the signer.
* See https://www.w3.org/TR/did-core/#authentication
* @returns {ProofPurpose}
*/
  static authentication(): ProofPurpose;
/**
* Serializes a `ProofPurpose` to a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `ProofPurpose` from a JSON object.
* @param {any} json
* @returns {ProofPurpose}
*/
  static fromJSON(json: any): ProofPurpose;
/**
* Deep clones the object.
* @returns {ProofPurpose}
*/
  clone(): ProofPurpose;
}
/**
*/
export class Receipt {
  free(): void;
/**
* Returns a copy of the associated IOTA Tangle `Network`.
* @returns {Network}
*/
  network(): Network;
/**
* Returns a copy of the message `id`.
* @returns {string}
*/
  messageId(): string;
/**
* Returns a copy of the message `network_id`.
* @returns {string}
*/
  networkId(): string;
/**
* Returns a copy of the message `nonce`.
* @returns {string}
*/
  nonce(): string;
/**
* Serializes a `Receipt` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Receipt` from a JSON object.
* @param {any} json
* @returns {Receipt}
*/
  static fromJSON(json: any): Receipt;
/**
* Deep clones the object.
* @returns {Receipt}
*/
  clone(): Receipt;
}
/**
* An IOTA DID document resolved from the Tangle. Represents an integration chain message possibly
* merged with one or more `DiffMessages`.
*/
export class ResolvedDocument {
  free(): void;
/**
* Attempts to merge changes from a `DiffMessage` into this document and
* updates the `ResolvedDocument::diffMessageId`.
*
* If merging fails the document remains unmodified, otherwise this represents
* the merged document state.
*
* See `Document::mergeDiff`.
*
* # Errors
*
* Fails if the merge operation or signature verification on the diff fails.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {DiffMessage} diff_message
*/
  mergeDiffMessage(diff_message: DiffMessage): void;
/**
* Returns a copy of the inner DID document.
*
* NOTE: If the `ResolvedDocument` is no longer needed after calling this method
* then consider using `intoDocument()` for efficiency.
* @returns {Document}
*/
  document(): Document;
/**
* Consumes this object and returns the inner DID document.
*
* NOTE: trying to use the `ResolvedDocument` after calling this will throw an error.
* @returns {Document}
*/
  intoDocument(): Document;
/**
* Returns a copy of the diff chain message id.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @returns {string}
*/
  diffMessageId(): string;
/**
* Sets the diff chain message id.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {string} value
*/
  setDiffMessageId(value: string): void;
/**
* Returns a copy of the integration chain message id.
* @returns {string}
*/
  integrationMessageId(): string;
/**
* Sets the integration chain message id.
* @param {string} value
*/
  setIntegrationMessageId(value: string): void;
/**
* Serializes a `Document` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Document` object from a JSON object.
* @param {any} json
* @returns {ResolvedDocument}
*/
  static fromJSON(json: any): ResolvedDocument;
/**
* Deep clones the object.
* @returns {ResolvedDocument}
*/
  clone(): ResolvedDocument;
}
/**
*/
export class Resolver {
  free(): void;
/**
* Constructs a new `Resolver` with a default `Client` for
* the `Mainnet`.
*/
  constructor();
/**
* Returns a {@link ResolverBuilder} to construct a new `Resolver`.
* @returns {ResolverBuilder}
*/
  static builder(): ResolverBuilder;
/**
* Returns the `Client` corresponding to the given network name if one exists.
* @param {string} network_name
* @returns {Client | undefined}
*/
  getClient(network_name: string): Client | undefined;
/**
* Fetches the `Document` of the given `DID`.
* @param {DID | string} did
* @returns {Promise<ResolvedDocument>}
*/
  resolve(did: DID | string): Promise<ResolvedDocument>;
/**
* Fetches the `DocumentHistory` of the given `DID`.
* @param {DID | string} did
* @returns {Promise<DocumentHistory>}
*/
  resolveHistory(did: DID | string): Promise<DocumentHistory>;
/**
* Returns the `DiffChainHistory` of a diff chain starting from a `Document` on the
* integration chain.
*
* NOTE: the document must have been published to the Tangle and have a valid message id.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
* @param {ResolvedDocument} document
* @returns {Promise<DiffChainHistory>}
*/
  resolveDiffHistory(document: ResolvedDocument): Promise<DiffChainHistory>;
/**
* Fetches the DID Document of the issuer on a `Credential`.
*
* ### Errors
*
* Errors if the issuer URL is not a valid `DID` or document resolution fails.
* @param {Credential} credential
* @returns {Promise<ResolvedDocument>}
*/
  resolveCredentialIssuer(credential: Credential): Promise<ResolvedDocument>;
/**
* Fetches all DID Documents of `Credential` issuers contained in a `Presentation`.
* Issuer documents are returned in arbitrary order.
*
* ### Errors
*
* Errors if any issuer URL is not a valid `DID` or document resolution fails.
* @param {Presentation} presentation
* @returns {Promise<Array<ResolvedDocument>>}
*/
  resolvePresentationIssuers(presentation: Presentation): Promise<Array<ResolvedDocument>>;
/**
* Fetches the DID Document of the holder of a `Presentation`.
*
* ### Errors
*
* Errors if the holder URL is missing, is not a valid `DID`, or document resolution fails.
* @param {Presentation} presentation
* @returns {Promise<ResolvedDocument>}
*/
  resolvePresentationHolder(presentation: Presentation): Promise<ResolvedDocument>;
/**
* Verifies a `Presentation`.
*
* ### Important
* See `PresentationValidator::validate` for information about which properties get
* validated and what is expected of the optional arguments `holder` and `issuer`.
*
* ### Resolution
* The DID Documents for the `holder` and `issuers` are optionally resolved if not given.
* If you already have up-to-date versions of these DID Documents, you may want
* to use `PresentationValidator::validate`.
* See also `Resolver::resolvePresentationIssuers` and `Resolver::resolvePresentationHolder`.
*
* ### Errors
* Errors from resolving the holder and issuer DID Documents, if not provided, will be returned immediately.
* Otherwise, errors from validating the presentation and its credentials will be returned
* according to the `fail_fast` parameter.
* @param {Presentation} presentation
* @param {PresentationValidationOptions} options
* @param {number} fail_fast
* @param {ResolvedDocument | undefined} holder
* @param {Array<ResolvedDocument> | undefined} issuers
* @returns {Promise<void>}
*/
  verifyPresentation(presentation: Presentation, options: PresentationValidationOptions, fail_fast: number, holder?: ResolvedDocument, issuers?: Array<ResolvedDocument>): Promise<void>;
}
/**
* Builder for configuring [`Clients`][Client] when constructing a [`Resolver`].
*/
export class ResolverBuilder {
  free(): void;
/**
* Constructs a new `ResolverBuilder` with no `Clients` configured.
*/
  constructor();
/**
* Inserts a `Client`.
*
* NOTE: replaces any previous `Client` or `Config` with the same network name.
* @param {Client} client
* @returns {ResolverBuilder}
*/
  client(client: Client): ResolverBuilder;
/**
* Inserts a `Config` used to create a `Client`.
*
* NOTE: replaces any previous `Client` or `Config` with the same network name.
* @param {IClientConfig} config
* @returns {ResolverBuilder}
*/
  clientConfig(config: IClientConfig): ResolverBuilder;
/**
* Constructs a new [`Resolver`] based on the builder configuration.
* @returns {Promise<Resolver>}
*/
  build(): Promise<Resolver>;
}
/**
* A compressed bitmap for managing credential revocation.
*/
export class RevocationBitmap {
  free(): void;
/**
* Creates a new `RevocationBitmap` instance.
*/
  constructor();
/**
* The name of the service type.
* @returns {string}
*/
  static type(): string;
/**
* Returns `true` if the credential at the given `index` is revoked.
* @param {number} index
* @returns {boolean}
*/
  isRevoked(index: number): boolean;
/**
* Mark the given index as revoked.
*
* Returns true if the index was absent from the set.
* @param {number} index
* @returns {boolean}
*/
  revoke(index: number): boolean;
/**
* Mark the index as not revoked.
*
* Returns true if the index was present in the set.
* @param {number} index
* @returns {boolean}
*/
  unrevoke(index: number): boolean;
/**
* Returns the number of revoked credentials.
* @returns {number}
*/
  len(): number;
/**
* Return the bitmap as a data url embedded in a service endpoint.
* @returns {string | string[] | Map<string, string[]>}
*/
  toEndpoint(): string | string[] | Map<string, string[]>;
/**
* Construct a `RevocationBitmap` from a data `url`.
* @param {string | string[] | Map<string, string[]>} endpoint
* @returns {RevocationBitmap}
*/
  static fromEndpoint(endpoint: string | string[] | Map<string, string[]>): RevocationBitmap;
}
/**
* A DID Document Service used to enable trusted interactions associated
* with a DID subject.
*
* See: https://www.w3.org/TR/did-core/#services
*/
export class Service {
  free(): void;
/**
* @param {IService} service
*/
  constructor(service: IService);
/**
* Returns a copy of the `Service` id.
* @returns {DIDUrl}
*/
  id(): DIDUrl;
/**
* Returns a copy of the `Service` type.
* @returns {string}
*/
  type(): string;
/**
* Returns a copy of the `Service` endpoint.
* @returns {string | string[] | Map<string, string[]>}
*/
  serviceEndpoint(): string | string[] | Map<string, string[]>;
/**
* Returns a copy of the custom properties on the `Service`.
* @returns {Map<string, any>}
*/
  properties(): Map<string, any>;
/**
* Serializes a `Service` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Service` object from a JSON object.
* @param {any} value
* @returns {Service}
*/
  static fromJSON(value: any): Service;
/**
* Deep clones the object.
* @returns {Service}
*/
  clone(): Service;
}
/**
*/
export class Signature {
  free(): void;
/**
* Creates a new `Signature`.
* @param {Uint8Array} data
*/
  constructor(data: Uint8Array);
/**
* Returns a copy of the signature as a `UInt8Array`.
* @returns {Uint8Array}
*/
  asBytes(): Uint8Array;
/**
* Serializes a `Signature` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a JSON object as `Signature`.
* @param {any} json_value
* @returns {Signature}
*/
  static fromJSON(json_value: any): Signature;
}
/**
* A test suite for the `Storage` interface.
*
* This module contains a set of tests that a correct storage implementation
* should pass. Note that not every edge case is tested.
*
* Tests usually rely on multiple interface methods being implemented, so they should only
* be run on a fully implemented version. That's why there is not a single test case for every
* interface method.
*/
export class StorageTestSuite {
  free(): void;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static didCreateGenerateKeyTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static didCreatePrivateKeyTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static didListTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static didPurgeTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static keyGenerateTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static keyDeleteTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static keyInsertTest(storage: Storage): Promise<void>;
/**
* @param {Storage} storage
* @returns {Promise<void>}
*/
  static keySignEd25519Test(storage: Storage): Promise<void>;
/**
* @param {Storage} alice_storage
* @param {Storage} bob_storage
* @returns {Promise<void>}
*/
  static encryptionTest(alice_storage: Storage, bob_storage: Storage): Promise<void>;
}
/**
*/
export class Timestamp {
  free(): void;
/**
* Parses a `Timestamp` from the provided input string.
* @param {string} input
* @returns {Timestamp}
*/
  static parse(input: string): Timestamp;
/**
* Creates a new `Timestamp` with the current date and time.
* @returns {Timestamp}
*/
  static nowUTC(): Timestamp;
/**
* Returns the `Timestamp` as an RFC 3339 `String`.
* @returns {string}
*/
  toRFC3339(): string;
/**
* Computes `self + duration`
*
* Returns `null` if the operation leads to a timestamp not in the valid range for [RFC 3339](https://tools.ietf.org/html/rfc3339).
* @param {Duration} duration
* @returns {Timestamp | undefined}
*/
  checkedAdd(duration: Duration): Timestamp | undefined;
/**
* Computes `self - duration`
*
* Returns `null` if the operation leads to a timestamp not in the valid range for [RFC 3339](https://tools.ietf.org/html/rfc3339).
* @param {Duration} duration
* @returns {Timestamp | undefined}
*/
  checkedSub(duration: Duration): Timestamp | undefined;
/**
* Serializes a `Timestamp` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `Timestamp` from a JSON object.
* @param {any} json
* @returns {Timestamp}
*/
  static fromJSON(json: any): Timestamp;
}
/**
*/
export class VerificationMethod {
  free(): void;
/**
* Creates a new `VerificationMethod` object from the given `did` and public key.
* @param {DID} did
* @param {number} key_type
* @param {Uint8Array} public_key
* @param {string} fragment
*/
  constructor(did: DID, key_type: number, public_key: Uint8Array, fragment: string);
/**
* Returns a copy of the `id` `DIDUrl` of the `VerificationMethod` object.
* @returns {DIDUrl}
*/
  id(): DIDUrl;
/**
* Returns a copy of the `controller` `DID` of the `VerificationMethod` object.
* @returns {DID}
*/
  controller(): DID;
/**
* Sets the `controller` `DID` of the `VerificationMethod` object.
* @param {DID} did
*/
  SetController(did: DID): void;
/**
* Returns a copy of the `VerificationMethod` type.
* @returns {MethodType}
*/
  type(): MethodType;
/**
* Returns a copy of the `VerificationMethod` public key data.
* @returns {MethodData}
*/
  data(): MethodData;
/**
* Serializes a `VerificationMethod` object as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `VerificationMethod` object from a JSON object.
* @param {any} value
* @returns {VerificationMethod}
*/
  static fromJSON(value: any): VerificationMethod;
/**
* Deep clones the object.
* @returns {VerificationMethod}
*/
  clone(): VerificationMethod;
}
/**
* Holds additional proof verification options.
* See `IVerifierOptions`.
*/
export class VerifierOptions {
  free(): void;
/**
* Creates a new `VerifierOptions` from the given fields.
*
* Throws an error if any of the options are invalid.
* @param {IVerifierOptions} options
*/
  constructor(options: IVerifierOptions);
/**
* Creates a new `VerifierOptions` with default options.
* @returns {VerifierOptions}
*/
  static default(): VerifierOptions;
/**
* Serializes a `VerifierOptions` as a JSON object.
* @returns {any}
*/
  toJSON(): any;
/**
* Deserializes a `VerifierOptions` from a JSON object.
* @param {any} json
* @returns {VerifierOptions}
*/
  static fromJSON(json: any): VerifierOptions;
/**
* Deep clones the object.
* @returns {VerifierOptions}
*/
  clone(): VerifierOptions;
}
/**
* An implementation of `X25519` Elliptic-curve Diffie-Hellman (ECDH) cryptographic key exchange.
*/
export class X25519 {
  free(): void;
/**
* Length in bytes of an X25519 private key.
* @returns {number}
*/
  static PRIVATE_KEY_LENGTH(): number;
/**
* Length in bytes of an X25519 public key.
* @returns {number}
*/
  static PUBLIC_KEY_LENGTH(): number;
/**
* Performs Diffie-Hellman key exchange using the private key of the first party with the
* public key of the second party, resulting in a shared secret.
* @param {Uint8Array} privateKey
* @param {Uint8Array} publicKey
* @returns {Uint8Array}
*/
  static keyExchange(privateKey: Uint8Array, publicKey: Uint8Array): Uint8Array;
/**
* Transforms an `Ed25519` private key to an `X25519` private key.
*
* This is possible because Ed25519 is birationally equivalent to Curve25519 used by X25519.
* @param {Uint8Array} privateKey
* @returns {Uint8Array}
*/
  static Ed25519toX25519Private(privateKey: Uint8Array): Uint8Array;
/**
* Transforms an `Ed25519` public key to an `X25519` public key.
*
* This is possible because Ed25519 is birationally equivalent to Curve25519 used by X25519.
* @param {Uint8Array} publicKey
* @returns {Uint8Array}
*/
  static Ed25519toX25519Public(publicKey: Uint8Array): Uint8Array;
}
