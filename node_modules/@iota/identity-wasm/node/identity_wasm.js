if (!globalThis.fetch) {
    const fetch = require('node-fetch')
    globalThis.Headers = fetch.Headers
    globalThis.Request = fetch.Request
    globalThis.Response = fetch.Response
    globalThis.fetch = fetch
}
let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;
const { TextDecoder, TextEncoder, inspect } = require(`util`);

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0;
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedInt32Memory0;
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = new FinalizationRegistry(state => {
    wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state)
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_34(arg0, arg1, arg2) {
    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hdcd0b8367bd8bfe2(arg0, arg1, addHeapObject(arg2));
}

function __wbg_adapter_37(arg0, arg1) {
    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h4fe003293c171f86(arg0, arg1);
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

let stack_pointer = 32;

function addBorrowedObject(obj) {
    if (stack_pointer == 1) throw new Error('out of js stack');
    heap[--stack_pointer] = obj;
    return stack_pointer;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* Initializes the console error panic hook for better error messages
*/
module.exports.start = function() {
    wasm.start();
};

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}

function notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }
function __wbg_adapter_655(arg0, arg1, arg2, arg3) {
    wasm.wasm_bindgen__convert__closures__invoke2_mut__hd12e749677640a32(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}

/**
*/
module.exports.DIDMessageEncoding = Object.freeze({ Json:0,"0":"Json",JsonBrotli:1,"1":"JsonBrotli", });
/**
* Controls validation behaviour when checking whether or not a credential has been revoked by its
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status).
*/
module.exports.StatusCheck = Object.freeze({
/**
* Validate the status if supported, reject any unsupported
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status) types.
*
* Only `RevocationBitmap2022` is currently supported.
*
* This is the default.
*/
Strict:0,"0":"Strict",
/**
* Validate the status if supported, skip any unsupported
* [`credentialStatus`](https://www.w3.org/TR/vc-data-model/#status) types.
*/
SkipUnsupported:1,"1":"SkipUnsupported",
/**
* Skip all status checks.
*/
SkipAll:2,"2":"SkipAll", });
/**
* Declares how credential subjects must relate to the presentation holder during validation.
* See `PresentationValidationOptions::subject_holder_relationship`.
*
* See also the [Subject-Holder Relationship](https://www.w3.org/TR/vc-data-model/#subject-holder-relationships) section of the specification.
*/
module.exports.SubjectHolderRelationship = Object.freeze({
/**
* The holder must always match the subject on all credentials, regardless of their [`nonTransferable`](https://www.w3.org/TR/vc-data-model/#nontransferable-property) property.
* This variant is the default used if no other variant is specified when constructing a new
* `PresentationValidationOptions`.
*/
AlwaysSubject:0,"0":"AlwaysSubject",
/**
* The holder must match the subject only for credentials where the [`nonTransferable`](https://www.w3.org/TR/vc-data-model/#nontransferable-property) property is `true`.
*/
SubjectOnNonTransferable:1,"1":"SubjectOnNonTransferable",
/**
* The holder is not required to have any kind of relationship to any credential subject.
*/
Any:2,"2":"Any", });
/**
* Declares when validation should return if an error occurs.
*/
module.exports.FailFast = Object.freeze({
/**
* Return all errors that occur during validation.
*/
AllErrors:0,"0":"AllErrors",
/**
* Return after the first error occurs.
*/
FirstError:1,"1":"FirstError", });
/**
*/
module.exports.KeyType = Object.freeze({ Ed25519:1,"1":"Ed25519",X25519:2,"2":"X25519", });
/**
*/
module.exports.MethodRelationship = Object.freeze({ Authentication:0,"0":"Authentication",AssertionMethod:1,"1":"AssertionMethod",KeyAgreement:2,"2":"KeyAgreement",CapabilityDelegation:3,"3":"CapabilityDelegation",CapabilityInvocation:4,"4":"CapabilityInvocation", });

const AccountFinalization = new FinalizationRegistry(ptr => wasm.__wbg_account_free(ptr));
/**
* An account manages one identity.
*
* It handles private keys, writing to storage and
* publishing to the Tangle.
*/
class Account {

    static __wrap(ptr) {
        const obj = Object.create(Account.prototype);
        obj.ptr = ptr;
        AccountFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AccountFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_account_free(ptr);
    }
    /**
    * Attach one or more verification relationships to a method.
    *
    * Note: the method must exist and be in the set of verification methods;
    * it cannot be an embedded method.
    * @param {AttachMethodRelationshipOptions} options
    * @returns {Promise<void>}
    */
    attachMethodRelationships(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_attachMethodRelationships(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Adds a new verification method to the DID document.
    * @param {CreateMethodOptions} options
    * @returns {Promise<void>}
    */
    createMethod(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_createMethod(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Detaches the given relationship from the given method, if the method exists.
    * @param {DetachMethodRelationshipOptions} options
    * @returns {Promise<void>}
    */
    detachMethodRelationships(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_detachMethodRelationships(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Returns the {@link DID} of the managed identity.
    * @returns {DID}
    */
    did() {
        const ret = wasm.account_did(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Returns whether auto-publish is enabled.
    * @returns {boolean}
    */
    autopublish() {
        const ret = wasm.account_autopublish(this.ptr);
        return ret !== 0;
    }
    /**
    * Returns the auto-save configuration value.
    * @returns {AutoSave}
    */
    autosave() {
        const ret = wasm.account_autosave(this.ptr);
        return AutoSave.__wrap(ret);
    }
    /**
    * Returns a copy of the document managed by the `Account`.
    *
    * Note: the returned document only has a valid signature after publishing an integration chain update.
    * In general, for use cases where the signature is required, it is advisable to resolve the
    * document from the Tangle.
    * @returns {Document}
    */
    document() {
        const ret = wasm.account_document(this.ptr);
        return Document.__wrap(ret);
    }
    /**
    * Resolves the DID Document associated with this `Account` from the Tangle.
    * @returns {Promise<ResolvedDocument>}
    */
    resolveIdentity() {
        const ret = wasm.account_resolveIdentity(this.ptr);
        return takeObject(ret);
    }
    /**
    * Removes the identity from the local storage entirely.
    *
    * Note: This will remove all associated document updates and key material - recovery is NOT POSSIBLE!
    * @returns {Promise<void>}
    */
    deleteIdentity() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.account_deleteIdentity(ptr);
        return takeObject(ret);
    }
    /**
    * Push all unpublished changes to the tangle in a single message.
    * @param {PublishOptions | undefined} publish_options
    * @returns {Promise<void>}
    */
    publish(publish_options) {
        const ret = wasm.account_publish(this.ptr, isLikeNone(publish_options) ? 0 : addHeapObject(publish_options));
        return takeObject(ret);
    }
    /**
    * Signs a {@link Credential} with the key specified by `fragment`.
    * @param {string} fragment
    * @param {Credential} credential
    * @param {ProofOptions} options
    * @returns {Promise<Credential>}
    */
    createSignedCredential(fragment, credential, options) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(credential, Credential);
        _assertClass(options, ProofOptions);
        const ret = wasm.account_createSignedCredential(this.ptr, ptr0, len0, credential.ptr, options.ptr);
        return takeObject(ret);
    }
    /**
    * Signs a {@link Document} with the key specified by `fragment`.
    * @param {string} fragment
    * @param {Document} document
    * @param {ProofOptions} options
    * @returns {Promise<Document>}
    */
    createSignedDocument(fragment, document, options) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(document, Document);
        _assertClass(options, ProofOptions);
        const ret = wasm.account_createSignedDocument(this.ptr, ptr0, len0, document.ptr, options.ptr);
        return takeObject(ret);
    }
    /**
    * Signs a {@link Presentation} the key specified by `fragment`.
    * @param {string} fragment
    * @param {Presentation} presentation
    * @param {ProofOptions} options
    * @returns {Promise<Presentation>}
    */
    createSignedPresentation(fragment, presentation, options) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(presentation, Presentation);
        _assertClass(options, ProofOptions);
        const ret = wasm.account_createSignedPresentation(this.ptr, ptr0, len0, presentation.ptr, options.ptr);
        return takeObject(ret);
    }
    /**
    * Signs arbitrary `data` with the key specified by `fragment`.
    * @param {string} fragment
    * @param {any} data
    * @param {ProofOptions} options
    * @returns {Promise<any>}
    */
    createSignedData(fragment, data, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(options, ProofOptions);
            wasm.account_createSignedData(retptr, this.ptr, ptr0, len0, addBorrowedObject(data), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Overwrites the {@link Document} this account manages, **without doing any validation**.
    *
    * ### WARNING
    *
    * This method is dangerous and can easily corrupt the internal state,
    * potentially making the identity unusable. Only call this if you fully
    * understand the implications!
    * @param {Document} document
    * @returns {Promise<void>}
    */
    updateDocumentUnchecked(document) {
        _assertClass(document, Document);
        const ret = wasm.account_updateDocumentUnchecked(this.ptr, document.ptr);
        return takeObject(ret);
    }
    /**
    * Fetches the latest changes from the tangle and **overwrites** the local document.
    *
    * If a DID is managed from distributed accounts, this should be called before making changes
    * to the identity, to avoid publishing updates that would be ignored.
    * @returns {Promise<void>}
    */
    fetchDocument() {
        const ret = wasm.account_fetchDocument(this.ptr);
        return takeObject(ret);
    }
    /**
    * If the document has a `RevocationBitmap` service identified by `fragment`,
    * revoke all credentials with a `revocationBitmapIndex` in `credentialIndices`.
    * @param {string} fragment
    * @param {number | number[]} credentialIndices
    * @returns {Promise<void>}
    */
    revokeCredentials(fragment, credentialIndices) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.account_revokeCredentials(this.ptr, ptr0, len0, addHeapObject(credentialIndices));
        return takeObject(ret);
    }
    /**
    * If the document has a `RevocationBitmap` service identified by `fragment`,
    * unrevoke all credentials with a `revocationBitmapIndex` in `credentialIndices`.
    * @param {string} fragment
    * @param {number | number[]} credentialIndices
    * @returns {Promise<void>}
    */
    unrevokeCredentials(fragment, credentialIndices) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.account_unrevokeCredentials(this.ptr, ptr0, len0, addHeapObject(credentialIndices));
        return takeObject(ret);
    }
    /**
    * Encrypts the given `plaintext` with the specified `encryption_algorithm` and `cek_algorithm`.
    *
    * Returns an [`EncryptedData`] instance.
    * @param {Uint8Array} plaintext
    * @param {Uint8Array} associated_data
    * @param {EncryptionAlgorithm} encryption_algorithm
    * @param {CekAlgorithm} cek_algorithm
    * @param {Uint8Array} public_key
    * @returns {Promise<EncryptedData>}
    */
    encryptData(plaintext, associated_data, encryption_algorithm, cek_algorithm, public_key) {
        const ptr0 = passArray8ToWasm0(plaintext, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(associated_data, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        _assertClass(encryption_algorithm, EncryptionAlgorithm);
        _assertClass(cek_algorithm, CekAlgorithm);
        const ptr2 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.account_encryptData(this.ptr, ptr0, len0, ptr1, len1, encryption_algorithm.ptr, cek_algorithm.ptr, ptr2, len2);
        return takeObject(ret);
    }
    /**
    * Decrypts the given `data` with the key identified by `fragment` using the given `encryption_algorithm` and
    * `cek_algorithm`.
    *
    * Returns the decrypted text.
    * @param {EncryptedData} data
    * @param {EncryptionAlgorithm} encryption_algorithm
    * @param {CekAlgorithm} cek_algorithm
    * @param {string} fragment
    * @returns {Promise<Uint8Array>}
    */
    decryptData(data, encryption_algorithm, cek_algorithm, fragment) {
        _assertClass(data, EncryptedData);
        _assertClass(encryption_algorithm, EncryptionAlgorithm);
        _assertClass(cek_algorithm, CekAlgorithm);
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.account_decryptData(this.ptr, data.ptr, encryption_algorithm.ptr, cek_algorithm.ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Sets the `alsoKnownAs` property in the DID document.
    * @param {SetAlsoKnownAsOptions} options
    * @returns {Promise<void>}
    */
    setAlsoKnownAs(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_setAlsoKnownAs(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deletes a verification method if the method exists.
    * @param {DeleteMethodOptions} options
    * @returns {Promise<void>}
    */
    deleteMethod(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_deleteMethod(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deletes a Service if it exists.
    * @param {DeleteServiceOptions} options
    * @returns {Promise<void>}
    */
    deleteService(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_deleteService(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Sets the controllers of the DID document.
    * @param {SetControllerOptions} options
    * @returns {Promise<void>}
    */
    setController(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_setController(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Adds a new Service to the DID Document.
    * @param {CreateServiceOptions} options
    * @returns {Promise<void>}
    */
    createService(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.account_createService(retptr, this.ptr, addBorrowedObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.Account = Account;

const AccountBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_accountbuilder_free(ptr));
/**
* An [`Account`] builder for easy account configuration.
*
* To reduce memory usage, accounts created from the same builder share the same `Storage`
* used to store identities, and the same {@link Client} used to publish identities to the Tangle.
*
* The configuration on the other hand is cloned, and therefore unique for each built account.
* This means a builder can be reconfigured in-between account creations, without affecting
* the configuration of previously built accounts.
*/
class AccountBuilder {

    static __wrap(ptr) {
        const obj = Object.create(AccountBuilder.prototype);
        obj.ptr = ptr;
        AccountBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AccountBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_accountbuilder_free(ptr);
    }
    /**
    * Creates a new `AccountBuilder`.
    * @param {AccountBuilderOptions | undefined} options
    */
    constructor(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.accountbuilder_new(retptr, isLikeNone(options) ? 0 : addHeapObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AccountBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Loads an existing identity with the specified `did` using the current builder configuration.
    * The identity must exist in the configured `Storage`.
    * @param {DID} did
    * @returns {Promise<Account>}
    */
    loadIdentity(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(did, DID);
            wasm.accountbuilder_loadIdentity(retptr, this.ptr, did.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new identity based on the builder configuration and returns
    * an {@link Account} object to manage it.
    *
    * The identity is stored locally in the `Storage`. The DID network is automatically determined
    * by the {@link Client} used to publish it.
    *
    * @See {@link IdentitySetup} to customize the identity creation.
    * @param {IdentitySetup | undefined} identity_setup
    * @returns {Promise<Account>}
    */
    createIdentity(identity_setup) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.accountbuilder_createIdentity(retptr, this.ptr, isLikeNone(identity_setup) ? 0 : addHeapObject(identity_setup));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.AccountBuilder = AccountBuilder;

const AgreementInfoFinalization = new FinalizationRegistry(ptr => wasm.__wbg_agreementinfo_free(ptr));
/**
* Agreement information used as the input for the concat KDF.
*/
class AgreementInfo {

    static __wrap(ptr) {
        const obj = Object.create(AgreementInfo.prototype);
        obj.ptr = ptr;
        AgreementInfoFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AgreementInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_agreementinfo_free(ptr);
    }
    /**
    * Creates an `AgreementInfo` Object.
    * @param {Uint8Array} apu
    * @param {Uint8Array} apv
    * @param {Uint8Array} pub_info
    * @param {Uint8Array} priv_info
    */
    constructor(apu, apv, pub_info, priv_info) {
        const ptr0 = passArray8ToWasm0(apu, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(apv, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(pub_info, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passArray8ToWasm0(priv_info, wasm.__wbindgen_malloc);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.agreementinfo_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        return AgreementInfo.__wrap(ret);
    }
    /**
    * Returns a copy of `apu'
    * @returns {Uint8Array}
    */
    apu() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_apu(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of `apv'
    * @returns {Uint8Array}
    */
    apv() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_apv(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of `pubInfo'
    * @returns {Uint8Array}
    */
    pubInfo() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_pubInfo(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of `privInfo'
    * @returns {Uint8Array}
    */
    privInfo() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_privInfo(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes `AgreementInfo` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `AgreementInfo` from a JSON object.
    * @param {any} json_value
    * @returns {AgreementInfo}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.agreementinfo_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AgreementInfo.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.AgreementInfo = AgreementInfo;

const AutoSaveFinalization = new FinalizationRegistry(ptr => wasm.__wbg_autosave_free(ptr));
/**
*/
class AutoSave {

    static __wrap(ptr) {
        const obj = Object.create(AutoSave.prototype);
        obj.ptr = ptr;
        AutoSaveFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AutoSaveFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_autosave_free(ptr);
    }
    /**
    * Never save.
    * @returns {AutoSave}
    */
    static never() {
        const ret = wasm.autosave_never();
        return AutoSave.__wrap(ret);
    }
    /**
    * Save after every action.
    * @returns {AutoSave}
    */
    static every() {
        const ret = wasm.autosave_every();
        return AutoSave.__wrap(ret);
    }
    /**
    * Save after every N actions.
    * @param {number} number_of_actions
    * @returns {AutoSave}
    */
    static batch(number_of_actions) {
        const ret = wasm.autosave_batch(number_of_actions);
        return AutoSave.__wrap(ret);
    }
    /**
    * Serializes `AutoSave` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.autosave_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `AutoSave` from a JSON object.
    * @param {any} json_value
    * @returns {AutoSave}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.autosave_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AutoSave.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.AutoSave = AutoSave;

const CekAlgorithmFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cekalgorithm_free(ptr));
/**
* Supported algorithms used to determine and potentially encrypt the content encryption key (CEK).
*/
class CekAlgorithm {

    static __wrap(ptr) {
        const obj = Object.create(CekAlgorithm.prototype);
        obj.ptr = ptr;
        CekAlgorithmFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CekAlgorithmFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cekalgorithm_free(ptr);
    }
    /**
    * Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.
    * @param {AgreementInfo} agreement
    * @returns {CekAlgorithm}
    */
    static EcdhEs(agreement) {
        _assertClass(agreement, AgreementInfo);
        const ret = wasm.cekalgorithm_EcdhEs(agreement.ptr);
        return CekAlgorithm.__wrap(ret);
    }
    /**
    * Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF.
    * @param {AgreementInfo} agreement
    * @returns {CekAlgorithm}
    */
    static EcdhEsA256Kw(agreement) {
        _assertClass(agreement, AgreementInfo);
        const ret = wasm.cekalgorithm_EcdhEsA256Kw(agreement.ptr);
        return CekAlgorithm.__wrap(ret);
    }
    /**
    * Serializes `CekAlgorithm` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cekalgorithm_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `CekAlgorithm` from a JSON object.
    * @param {any} json_value
    * @returns {CekAlgorithm}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cekalgorithm_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CekAlgorithm.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.CekAlgorithm = CekAlgorithm;

const ChainStateFinalization = new FinalizationRegistry(ptr => wasm.__wbg_chainstate_free(ptr));
/**
*/
class ChainState {

    static __wrap(ptr) {
        const obj = Object.create(ChainState.prototype);
        obj.ptr = ptr;
        ChainStateFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ChainStateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_chainstate_free(ptr);
    }
    /**
    * Serializes a `ChainState` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.chainstate_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a JSON object as `ChainState`.
    * @param {any} json_value
    * @returns {ChainState}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.chainstate_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ChainState.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ChainState = ChainState;

const ClientFinalization = new FinalizationRegistry(ptr => wasm.__wbg_client_free(ptr));
/**
*/
class Client {

    static __wrap(ptr) {
        const obj = Object.create(Client.prototype);
        obj.ptr = ptr;
        ClientFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ClientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_client_free(ptr);
    }
    /**
    * Creates a new `Client` with default settings.
    */
    constructor() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.client_new(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Client.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `Client` with the given settings.
    * @param {IClientConfig} config
    * @returns {Promise<Client>}
    */
    static fromConfig(config) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.client_fromConfig(retptr, addHeapObject(config));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the `Client` Tangle network.
    * @returns {Network}
    */
    network() {
        const ret = wasm.client_network(this.ptr);
        return Network.__wrap(ret);
    }
    /**
    * Publishes a {@link Document} to the Tangle.
    * @param {Document} document
    * @returns {Promise<Receipt>}
    */
    publishDocument(document) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, Document);
            wasm.client_publishDocument(retptr, this.ptr, document.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Publishes a `DiffMessage` to the Tangle.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {string} message_id
    * @param {DiffMessage} diff
    * @returns {Promise<Receipt>}
    */
    publishDiff(message_id, diff) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(diff, DiffMessage);
            wasm.client_publishDiff(retptr, this.ptr, ptr0, len0, diff.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Publishes arbitrary JSON data to the specified index on the Tangle.
    * @param {string} index
    * @param {any} data
    * @returns {Promise<Receipt>}
    */
    publishJSON(index, data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.client_publishJSON(retptr, this.ptr, ptr0, len0, addBorrowedObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Publishes arbitrary JSON data to the specified index on the Tangle.
    * Retries (promotes or reattaches) the message until it’s included (referenced by a milestone).
    * Default interval is 5 seconds and max attempts is 40.
    * @param {string} index
    * @param {any} data
    * @param {number | undefined} interval
    * @param {number | undefined} max_attempts
    * @returns {Promise<any>}
    */
    publishJsonWithRetry(index, data, interval, max_attempts) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.client_publishJsonWithRetry(retptr, this.ptr, ptr0, len0, addBorrowedObject(data), !isLikeNone(interval), isLikeNone(interval) ? 0 : interval, !isLikeNone(max_attempts), isLikeNone(max_attempts) ? 0 : max_attempts);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Checks if a message is confirmed by a milestone.
    * @param {string} messageId
    * @returns {Promise<boolean>}
    */
    isMessageIncluded(messageId) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(messageId, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.client_isMessageIncluded(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Fetch the DID document specified by the given `DID`.
    * @param {DID | string} did
    * @returns {Promise<ResolvedDocument>}
    */
    resolve(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.client_resolve(retptr, this.ptr, addHeapObject(did));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the message history of the given DID.
    * @param {DID | string} did
    * @returns {Promise<DocumentHistory>}
    */
    resolveHistory(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.client_resolveHistory(retptr, this.ptr, addHeapObject(did));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the `DiffChainHistory` of a diff chain starting from a document on the
    * integration chain.
    *
    * NOTE: the document must have been published to the tangle and have a valid message id and
    * capability invocation method.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {ResolvedDocument} document
    * @returns {Promise<DiffChainHistory>}
    */
    resolveDiffHistory(document) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, ResolvedDocument);
            wasm.client_resolveDiffHistory(retptr, this.ptr, document.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Client = Client;

const CredentialFinalization = new FinalizationRegistry(ptr => wasm.__wbg_credential_free(ptr));
/**
*/
class Credential {

    static __wrap(ptr) {
        const obj = Object.create(Credential.prototype);
        obj.ptr = ptr;
        CredentialFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CredentialFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_credential_free(ptr);
    }
    /**
    * Returns the base JSON-LD context.
    * @returns {string}
    */
    static BaseContext() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_BaseContext(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * Returns the base type.
    * @returns {string}
    */
    static BaseType() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_BaseType(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Constructs a new `Credential`.
    * @param {ICredential} values
    */
    constructor(values) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_new(retptr, addHeapObject(values));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the JSON-LD context(s) applicable to the `Credential`.
    * @returns {Array<string | Record<string, any>>}
    */
    context() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_context(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the unique `URI` identifying the `Credential` .
    * @returns {string | undefined}
    */
    id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the URIs defining the type of the `Credential`.
    * @returns {Array<string>}
    */
    type() {
        const ret = wasm.credential_type(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns a copy of the `Credential` subject(s).
    * @returns {Array<Subject>}
    */
    credentialSubject() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_credentialSubject(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the issuer of the `Credential`.
    * @returns {string | Issuer}
    */
    issuer() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_issuer(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the timestamp of when the `Credential` becomes valid.
    * @returns {Timestamp}
    */
    issuanceDate() {
        const ret = wasm.credential_issuanceDate(this.ptr);
        return Timestamp.__wrap(ret);
    }
    /**
    * Returns a copy of the timestamp of when the `Credential` should no longer be considered valid.
    * @returns {Timestamp | undefined}
    */
    expirationDate() {
        const ret = wasm.credential_expirationDate(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Returns a copy of the information used to determine the current status of the `Credential`.
    * @returns {Array<Status>}
    */
    credentialStatus() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_credentialStatus(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the information used to assist in the enforcement of a specific `Credential` structure.
    * @returns {Array<Schema>}
    */
    credentialSchema() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_credentialSchema(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the service(s) used to refresh an expired `Credential`.
    * @returns {Array<RefreshService>}
    */
    refreshService() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_refreshService(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the terms-of-use specified by the `Credential` issuer.
    * @returns {Array<Policy>}
    */
    termsOfUse() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_termsOfUse(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the human-readable evidence used to support the claims within the `Credential`.
    * @returns {Array<Evidence>}
    */
    evidence() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_evidence(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns whether or not the `Credential` must only be contained within a {@link Presentation}
    * with a proof issued from the `Credential` subject.
    * @returns {boolean | undefined}
    */
    nonTransferable() {
        const ret = wasm.credential_nonTransferable(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
    * Returns a copy of the proof used to verify the `Credential`.
    * @returns {Proof | undefined}
    */
    proof() {
        const ret = wasm.credential_proof(this.ptr);
        return ret === 0 ? undefined : Proof.__wrap(ret);
    }
    /**
    * Returns a copy of the miscellaneous properties on the `Credential`.
    * @returns {Map<string, any>}
    */
    properties() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_properties(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Credential` to a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Credential` from a JSON object.
    * @param {any} json
    * @returns {Credential}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credential_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Credential}
    */
    clone() {
        const ret = wasm.credential_clone(this.ptr);
        return Credential.__wrap(ret);
    }
}
module.exports.Credential = Credential;

const CredentialValidationOptionsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_credentialvalidationoptions_free(ptr));
/**
* Options to declare validation criteria when validating credentials.
*/
class CredentialValidationOptions {

    static __wrap(ptr) {
        const obj = Object.create(CredentialValidationOptions.prototype);
        obj.ptr = ptr;
        CredentialValidationOptionsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CredentialValidationOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_credentialvalidationoptions_free(ptr);
    }
    /**
    * Creates a new `CredentialValidationOptions` from the given fields.
    *
    * Throws an error if any of the options are invalid.
    * @param {ICredentialValidationOptions} options
    */
    constructor(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credentialvalidationoptions_new(retptr, addHeapObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CredentialValidationOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `CredentialValidationOptions` with defaults.
    * @returns {CredentialValidationOptions}
    */
    static default() {
        const ret = wasm.credentialvalidationoptions_default();
        return CredentialValidationOptions.__wrap(ret);
    }
    /**
    * Serializes a `CredentialValidationOptions` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credentialvalidationoptions_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `CredentialValidationOptions` from a JSON object.
    * @param {any} json
    * @returns {CredentialValidationOptions}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.credentialvalidationoptions_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return CredentialValidationOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {CredentialValidationOptions}
    */
    clone() {
        const ret = wasm.credentialvalidationoptions_clone(this.ptr);
        return CredentialValidationOptions.__wrap(ret);
    }
}
module.exports.CredentialValidationOptions = CredentialValidationOptions;

const CredentialValidatorFinalization = new FinalizationRegistry(ptr => wasm.__wbg_credentialvalidator_free(ptr));
/**
*/
class CredentialValidator {

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CredentialValidatorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_credentialvalidator_free(ptr);
    }
    /**
    * Validates a `Credential`.
    *
    * The following properties are validated according to `options`:
    * - the issuer's signature,
    * - the expiration date,
    * - the issuance date,
    * - the semantic structure.
    *
    * ### Warning
    * The lack of an error returned from this method is in of itself not enough to conclude that the credential can be
    * trusted. This section contains more information on additional checks that should be carried out before and after
    * calling this method.
    *
    * #### The state of the issuer's DID Document
    * The caller must ensure that `issuer` represents an up-to-date DID Document. The convenience method
    * `Resolver::resolveCredentialIssuer` can help extract the latest available state of the issuer's DID Document.
    *
    * #### Properties that are not validated
    *  There are many properties defined in [The Verifiable Credentials Data Model](https://www.w3.org/TR/vc-data-model/) that are **not** validated, such as:
    * `credentialStatus`, `type`, `credentialSchema`, `refreshService`, **and more**.
    * These should be manually checked after validation, according to your requirements.
    *
    * ### Errors
    * An error is returned whenever a validated condition is not satisfied.
    * @param {Credential} credential
    * @param {Document | ResolvedDocument} issuer
    * @param {CredentialValidationOptions} options
    * @param {number} fail_fast
    */
    static validate(credential, issuer, options, fail_fast) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            _assertClass(options, CredentialValidationOptions);
            wasm.credentialvalidator_validate(retptr, credential.ptr, addBorrowedObject(issuer), options.ptr, fail_fast);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Validates the semantic structure of the `Credential`.
    *
    * ### Warning
    * This does not validate against the credential's schema nor the structure of the subject claims.
    * @param {Credential} credential
    */
    static checkStructure(credential) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            wasm.credentialvalidator_checkStructure(retptr, credential.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Validate that the credential expires on or after the specified timestamp.
    * @param {Credential} credential
    * @param {Timestamp} timestamp
    */
    static checkExpiresOnOrAfter(credential, timestamp) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            _assertClass(timestamp, Timestamp);
            wasm.credentialvalidator_checkExpiresOnOrAfter(retptr, credential.ptr, timestamp.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Validate that the credential is issued on or before the specified timestamp.
    * @param {Credential} credential
    * @param {Timestamp} timestamp
    */
    static checkIssuedOnOrBefore(credential, timestamp) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            _assertClass(timestamp, Timestamp);
            wasm.credentialvalidator_checkIssuedOnOrBefore(retptr, credential.ptr, timestamp.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Verify the signature using the DID Document of a trusted issuer.
    *
    * # Warning
    * The caller must ensure that the DID Documents of the trusted issuers are up-to-date.
    * ### Errors
    * This method immediately returns an error if
    * the credential issuer' url cannot be parsed to a DID belonging to one of the trusted issuers. Otherwise an attempt
    * to verify the credential's signature will be made and an error is returned upon failure.
    * @param {Credential} credential
    * @param {Array<Document> | Array<ResolvedDocument>} trusted_issuers
    * @param {VerifierOptions} options
    */
    static verifySignature(credential, trusted_issuers, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            _assertClass(options, VerifierOptions);
            wasm.credentialvalidator_verifySignature(retptr, credential.ptr, addBorrowedObject(trusted_issuers), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Validate that the relationship between the `holder` and the credential subjects is in accordance with
    * `relationship`. The `holder_url` parameter is expected to be the URL of the holder.
    * @param {Credential} credential
    * @param {string} holder_url
    * @param {number} relationship
    */
    static check_subject_holder_relationship(credential, holder_url, relationship) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            const ptr0 = passStringToWasm0(holder_url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.credentialvalidator_check_subject_holder_relationship(retptr, credential.ptr, ptr0, len0, relationship);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Checks whether the credential status has been revoked.
    *
    * Only supports `BitmapRevocation2022`.
    * @param {Credential} credential
    * @param {Array<Document> | Array<ResolvedDocument>} trustedIssuers
    * @param {number} statusCheck
    */
    static checkStatus(credential, trustedIssuers, statusCheck) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            wasm.credentialvalidator_checkStatus(retptr, credential.ptr, addBorrowedObject(trustedIssuers), statusCheck);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.CredentialValidator = CredentialValidator;

const DIDFinalization = new FinalizationRegistry(ptr => wasm.__wbg_did_free(ptr));
/**
* @typicalname did
*/
class DID {

    static __wrap(ptr) {
        const obj = Object.create(DID.prototype);
        obj.ptr = ptr;
        DIDFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            networkName: this.networkName,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DIDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_did_free(ptr);
    }
    /**
    * Creates a new `DID` from a public key.
    * @param {Uint8Array} public_key
    * @param {string | undefined} network
    */
    constructor(public_key, network) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            var ptr1 = isLikeNone(network) ? 0 : passStringToWasm0(network, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len1 = WASM_VECTOR_LEN;
            wasm.did_new(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DID.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Parses a `DID` from the input string.
    * @param {string} input
    * @returns {DID}
    */
    static parse(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.did_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DID.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the IOTA tangle network of the `DID`.
    * @returns {Network}
    */
    network() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.did_network(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Network.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the IOTA tangle network of the `DID`.
    */
    get networkName() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.did_network_name(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the unique tag of the `DID`.
    * @returns {string}
    */
    tag() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.did_tag(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Construct a new `DIDUrl` by joining with a relative DID Url string.
    * @param {string} segment
    * @returns {DIDUrl}
    */
    join(segment) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(segment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.did_join(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DIDUrl.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Clones the `DID` into a `DIDUrl`.
    * @returns {DIDUrl}
    */
    toUrl() {
        const ret = wasm.did_toUrl(this.ptr);
        return DIDUrl.__wrap(ret);
    }
    /**
    * Converts the `DID` into a `DIDUrl`.
    * @returns {DIDUrl}
    */
    intoUrl() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.did_intoUrl(ptr);
        return DIDUrl.__wrap(ret);
    }
    /**
    * Returns the `DID` as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.did_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Deserializes a JSON object as `DID`.
    * @param {any} json_value
    * @returns {DID}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.did_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DID.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `DID` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        const ret = wasm.did_toJSON(this.ptr);
        return takeObject(ret);
    }
    /**
    * Deep clones the object.
    * @returns {DID}
    */
    clone() {
        const ret = wasm.did_clone(this.ptr);
        return DID.__wrap(ret);
    }
}
module.exports.DID = DID;

const DIDUrlFinalization = new FinalizationRegistry(ptr => wasm.__wbg_didurl_free(ptr));
/**
* @typicalname didUrl
*/
class DIDUrl {

    static __wrap(ptr) {
        const obj = Object.create(DIDUrl.prototype);
        obj.ptr = ptr;
        DIDUrlFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DIDUrlFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_didurl_free(ptr);
    }
    /**
    * Parses a `DIDUrl` from the input string.
    * @param {string} input
    * @returns {DIDUrl}
    */
    static parse(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.didurl_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DIDUrl.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return a copy of the `DID` section of the `DIDUrl`.
    * @returns {DID}
    */
    did() {
        const ret = wasm.didurl_did(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Return a copy of the relative DID Url as a string, including only the path, query, and fragment.
    * @returns {string}
    */
    urlStr() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_urlStr(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the `DIDUrl` method fragment, if any. Excludes the leading '#'.
    * @returns {string | undefined}
    */
    fragment() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_fragment(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Sets the `fragment` component of the `DIDUrl`.
    * @param {string | undefined} value
    */
    setFragment(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm.didurl_setFragment(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the `DIDUrl` path.
    * @returns {string | undefined}
    */
    path() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_path(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Sets the `path` component of the `DIDUrl`.
    * @param {string | undefined} value
    */
    setPath(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm.didurl_setPath(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the `DIDUrl` method query, if any. Excludes the leading '?'.
    * @returns {string | undefined}
    */
    query() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_query(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Sets the `query` component of the `DIDUrl`.
    * @param {string | undefined} value
    */
    setQuery(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm.didurl_setQuery(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Append a string representing a path, query, and/or fragment, returning a new `DIDUrl`.
    *
    * Must begin with a valid delimiter character: '/', '?', '#'. Overwrites the existing URL
    * segment and any following segments in order of path, query, then fragment.
    *
    * I.e.
    * - joining a path will clear the query and fragment.
    * - joining a query will clear the fragment.
    * - joining a fragment will only overwrite the fragment.
    * @param {string} segment
    * @returns {DIDUrl}
    */
    join(segment) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(segment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.didurl_join(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DIDUrl.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the `DIDUrl` as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Serializes a `DIDUrl` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.didurl_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deep clones the object.
    * @returns {DIDUrl}
    */
    clone() {
        const ret = wasm.didurl_clone(this.ptr);
        return DIDUrl.__wrap(ret);
    }
}
module.exports.DIDUrl = DIDUrl;

const DiffChainHistoryFinalization = new FinalizationRegistry(ptr => wasm.__wbg_diffchainhistory_free(ptr));
/**
* @deprecated since 0.5.0, diff chain features are slated for removal.
*/
class DiffChainHistory {

    static __wrap(ptr) {
        const obj = Object.create(DiffChainHistory.prototype);
        obj.ptr = ptr;
        DiffChainHistoryFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DiffChainHistoryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_diffchainhistory_free(ptr);
    }
    /**
    * Returns an `Array` of the diff chain `DiffMessages`.
    *
    * NOTE: this clones the field.
    * @returns {Array<DiffMessage>}
    */
    chainData() {
        const ret = wasm.diffchainhistory_chainData(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns an `Array` of `MessageIds` as strings.
    *
    * NOTE: this clones the field.
    * @returns {Array<string>}
    */
    spam() {
        const ret = wasm.diffchainhistory_spam(this.ptr);
        return takeObject(ret);
    }
    /**
    * Serializes as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffchainhistory_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes from a JSON object.
    * @param {any} json
    * @returns {DiffChainHistory}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffchainhistory_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DiffChainHistory.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.DiffChainHistory = DiffChainHistory;

const DiffMessageFinalization = new FinalizationRegistry(ptr => wasm.__wbg_diffmessage_free(ptr));
/**
* Defines the difference between two DID `Document`s' JSON representations.
*
* @deprecated since 0.5.0, diff chain features are slated for removal.
*/
class DiffMessage {

    static __wrap(ptr) {
        const obj = Object.create(DiffMessage.prototype);
        obj.ptr = ptr;
        DiffMessageFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DiffMessageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_diffmessage_free(ptr);
    }
    /**
    * Returns the DID of the associated DID Document.
    *
    * NOTE: clones the data.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {DID}
    */
    id() {
        const ret = wasm.diffmessage_id(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Returns a copy of the DID of the associated DID Document.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {DID}
    */
    did() {
        const ret = wasm.diffmessage_did(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Returns a copy of the raw contents of the DID Document diff as a JSON string.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {string}
    */
    diff() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffmessage_diff(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * Returns a copy of the message_id of the DID Document diff.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {string}
    */
    messageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffmessage_messageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Sets the message_id of the DID Document diff.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {string} message_id
    */
    setMessageId(message_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.diffmessage_setMessageId(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the Tangle message id of the previous DID Document diff.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {string}
    */
    previousMessageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffmessage_previousMessageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Sets the Tangle message id of the previous DID Document diff.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {string} message_id
    */
    setPreviousMessageId(message_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.diffmessage_setPreviousMessageId(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the proof.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {Proof | undefined}
    */
    proof() {
        const ret = wasm.diffmessage_proof(this.ptr);
        return ret === 0 ? undefined : Proof.__wrap(ret);
    }
    /**
    * Returns a new DID Document which is the result of merging `self`
    * with the given Document.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {Document} document
    * @returns {Document}
    */
    merge(document) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, Document);
            wasm.diffmessage_merge(retptr, this.ptr, document.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Document.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `DiffMessage` as a JSON object.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffmessage_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `DiffMessage` from a JSON object.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {any} json
    * @returns {DiffMessage}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.diffmessage_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DiffMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {DiffMessage}
    */
    clone() {
        const ret = wasm.diffmessage_clone(this.ptr);
        return DiffMessage.__wrap(ret);
    }
}
module.exports.DiffMessage = DiffMessage;

const DocumentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_document_free(ptr));
/**
*/
class Document {

    static __wrap(ptr) {
        const obj = Object.create(Document.prototype);
        obj.ptr = ptr;
        DocumentFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_document_free(ptr);
    }
    /**
    * Creates a new DID Document from the given `KeyPair`, network, and verification method
    * fragment name.
    *
    * The DID Document will be pre-populated with a single verification method
    * derived from the provided `KeyPair` embedded as a capability invocation
    * verification relationship. This method will have the DID URL fragment
    * `#sign-0` by default and can be easily retrieved with `Document::defaultSigningMethod`.
    *
    * NOTE: the generated document is unsigned, see `Document::signSelf`.
    *
    * Arguments:
    *
    * * keypair: the initial verification method is derived from the public key with this keypair.
    * * network: Tangle network to use for the DID, default `Network::mainnet`.
    * * fragment: name of the initial verification method, default "sign-0".
    * @param {KeyPair} keypair
    * @param {string | undefined} network
    * @param {string | undefined} fragment
    */
    constructor(keypair, network, fragment) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keypair, KeyPair);
            var ptr0 = isLikeNone(network) ? 0 : passStringToWasm0(network, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            var ptr1 = isLikeNone(fragment) ? 0 : passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len1 = WASM_VECTOR_LEN;
            wasm.document_new(retptr, keypair.ptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Document.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new DID Document from the given `VerificationMethod`.
    *
    * NOTE: the generated document is unsigned, see `Document::signSelf`.
    * @param {VerificationMethod} method
    * @returns {Document}
    */
    static fromVerificationMethod(method) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(method, VerificationMethod);
            wasm.document_fromVerificationMethod(retptr, method.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Document.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns whether the given {@link MethodType} can be used to sign document updates.
    * @param {MethodType} method_type
    * @returns {boolean}
    */
    static isSigningMethodType(method_type) {
        _assertClass(method_type, MethodType);
        const ret = wasm.document_isSigningMethodType(method_type.ptr);
        return ret !== 0;
    }
    /**
    * Returns a copy of the DID Document `id`.
    * @returns {DID}
    */
    id() {
        const ret = wasm.document_id(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Sets the controllers of the DID Document.
    *
    * Note: Duplicates will be ignored.
    * Use `null` to remove all controllers.
    * @param {DID | DID[] | null} controllers
    */
    setController(controllers) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_setController(retptr, this.ptr, addBorrowedObject(controllers));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Returns a list of document controllers.
    * @returns {DID[]}
    */
    controller() {
        const ret = wasm.document_controller(this.ptr);
        return takeObject(ret);
    }
    /**
    * Sets the `alsoKnownAs` property in the DID document.
    * @param {string | string[] | null} urls
    */
    setAlsoKnownAs(urls) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_setAlsoKnownAs(retptr, this.ptr, addBorrowedObject(urls));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Returns a set of the document's `alsoKnownAs`.
    * @returns {Array<string>}
    */
    alsoKnownAs() {
        const ret = wasm.document_alsoKnownAs(this.ptr);
        return takeObject(ret);
    }
    /**
    * Adds a custom property to the DID Document.
    * If the value is set to `null`, the custom property will be removed.
    *
    * ### WARNING
    * This method can overwrite existing properties like `id` and result in an invalid document.
    * @param {string} key
    * @param {any} value
    */
    setPropertyUnchecked(key, value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.document_setPropertyUnchecked(retptr, this.ptr, ptr0, len0, addBorrowedObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Returns a copy of the custom DID Document properties.
    * @returns {Map<string, any>}
    */
    properties() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_properties(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return a set of all {@link Service Services} in the document.
    * @returns {Service[]}
    */
    service() {
        const ret = wasm.document_service(this.ptr);
        return takeObject(ret);
    }
    /**
    * Add a new {@link Service} to the document.
    *
    * Returns `true` if the service was added.
    * @param {Service} service
    * @returns {boolean}
    */
    insertService(service) {
        _assertClass(service, Service);
        const ret = wasm.document_insertService(this.ptr, service.ptr);
        return ret !== 0;
    }
    /**
    * Remove a {@link Service} identified by the given {@link DIDUrl} from the document.
    *
    * Returns `true` if a service was removed.
    * @param {DIDUrl} did
    * @returns {boolean}
    */
    removeService(did) {
        _assertClass(did, DIDUrl);
        const ret = wasm.document_removeService(this.ptr, did.ptr);
        return ret !== 0;
    }
    /**
    * Returns a list of all {@link VerificationMethod} in the DID Document.
    * @returns {VerificationMethod[]}
    */
    methods() {
        const ret = wasm.document_methods(this.ptr);
        return takeObject(ret);
    }
    /**
    * Adds a new Verification Method to the DID Document.
    * @param {VerificationMethod} method
    * @param {MethodScope} scope
    */
    insertMethod(method, scope) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(method, VerificationMethod);
            _assertClass(scope, MethodScope);
            wasm.document_insertMethod(retptr, this.ptr, method.ptr, scope.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Removes all references to the specified Verification Method.
    * @param {DIDUrl} did
    */
    removeMethod(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(did, DIDUrl);
            wasm.document_removeMethod(retptr, this.ptr, did.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the first `VerificationMethod` with a capability invocation relationship
    * capable of signing this DID document.
    *
    * Throws an error if no signing method is present.
    * @returns {VerificationMethod}
    */
    defaultSigningMethod() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_defaultSigningMethod(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerificationMethod.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the first `VerificationMethod` with an `id` property
    * matching the provided `query`.
    *
    * Throws an error if the method is not found.
    * @param {DIDUrl | string} query
    * @param {MethodScope | undefined} scope
    * @returns {VerificationMethod | undefined}
    */
    resolveMethod(query, scope) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_resolveMethod(retptr, this.ptr, addBorrowedObject(query), isLikeNone(scope) ? 0 : addHeapObject(scope));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 === 0 ? undefined : VerificationMethod.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Attempts to resolve the given method query into a method capable of signing a document update.
    * @param {DIDUrl | string} query
    * @returns {VerificationMethod}
    */
    resolveSigningMethod(query) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_resolveSigningMethod(retptr, this.ptr, addBorrowedObject(query));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerificationMethod.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Attaches the relationship to the given method, if the method exists.
    *
    * Note: The method needs to be in the set of verification methods,
    * so it cannot be an embedded one.
    * @param {DIDUrl} did_url
    * @param {number} relationship
    * @returns {boolean}
    */
    attachMethodRelationship(did_url, relationship) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(did_url, DIDUrl);
            wasm.document_attachMethodRelationship(retptr, this.ptr, did_url.ptr, relationship);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 !== 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Detaches the given relationship from the given method, if the method exists.
    * @param {DIDUrl} did_url
    * @param {number} relationship
    * @returns {boolean}
    */
    detachMethodRelationship(did_url, relationship) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(did_url, DIDUrl);
            wasm.document_detachMethodRelationship(retptr, this.ptr, did_url.ptr, relationship);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 !== 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Signs the DID document with the verification method specified by `method_query`.
    * The `method_query` may be the full `DIDUrl` of the method or just its fragment,
    * e.g. "#sign-0".
    *
    * NOTE: does not validate whether the private key of the given `key_pair` corresponds to the
    * verification method. See `Document::verifySelfSigned`.
    * @param {KeyPair} key_pair
    * @param {DIDUrl | string} method_query
    */
    signSelf(key_pair, method_query) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(key_pair, KeyPair);
            wasm.document_signSelf(retptr, this.ptr, key_pair.ptr, addBorrowedObject(method_query));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Signs another DID document using the verification method specified by `method_query`.
    * The `method_query` may be the full `DIDUrl` of the method or just its fragment,
    * e.g. "#sign-0".
    *
    * `Document.signSelf` should be used in general, this throws an error if trying to operate
    * on the same document. This is intended for signing updates to a document where a sole
    * capability invocation method is rotated or replaced entirely.
    *
    * NOTE: does not validate whether the private key of the given `key_pair` corresponds to the
    * verification method. See {@link Document.verifyDocument}.
    * @param {Document} document
    * @param {KeyPair} key_pair
    * @param {DIDUrl | string} method_query
    */
    signDocument(document, key_pair, method_query) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, Document);
            _assertClass(key_pair, KeyPair);
            wasm.document_signDocument(retptr, this.ptr, document.ptr, key_pair.ptr, addBorrowedObject(method_query));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Creates a signature for the given `Credential` with the specified DID Document
    * Verification Method.
    * @param {Credential} credential
    * @param {Uint8Array} privateKey
    * @param {DIDUrl | string} methodQuery
    * @param {ProofOptions} options
    * @returns {Credential}
    */
    signCredential(credential, privateKey, methodQuery, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(options, ProofOptions);
            wasm.document_signCredential(retptr, this.ptr, credential.ptr, ptr0, len0, addBorrowedObject(methodQuery), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Credential.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Creates a signature for the given `Presentation` with the specified DID Document
    * Verification Method.
    * @param {Presentation} presentation
    * @param {Uint8Array} privateKey
    * @param {DIDUrl | string} methodQuery
    * @param {ProofOptions} options
    * @returns {Presentation}
    */
    signPresentation(presentation, privateKey, methodQuery, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(options, ProofOptions);
            wasm.document_signPresentation(retptr, this.ptr, presentation.ptr, ptr0, len0, addBorrowedObject(methodQuery), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Presentation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Creates a signature for the given `data` with the specified DID Document
    * Verification Method.
    *
    * NOTE: use `signSelf` or `signDocument` for DID Documents.
    * @param {any} data
    * @param {Uint8Array} privateKey
    * @param {DIDUrl | string} methodQuery
    * @param {ProofOptions} options
    * @returns {any}
    */
    signData(data, privateKey, methodQuery, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(options, ProofOptions);
            wasm.document_signData(retptr, this.ptr, addBorrowedObject(data), ptr0, len0, addBorrowedObject(methodQuery), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Verifies the authenticity of `data` using the target verification method.
    * @param {any} data
    * @param {VerifierOptions} options
    * @returns {boolean}
    */
    verifyData(data, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(options, VerifierOptions);
            wasm.document_verifyData(retptr, this.ptr, addBorrowedObject(data), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 !== 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Verifies that the signature on the DID document `signed` was generated by a valid method from
    * this DID document.
    *
    * # Errors
    *
    * Fails if:
    * - The signature proof section is missing in the `signed` document.
    * - The method is not found in this document.
    * - An unsupported verification method is used.
    * - The signature verification operation fails.
    * @param {Document} signed
    */
    verifyDocument(signed) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(signed, Document);
            wasm.document_verifyDocument(retptr, this.ptr, signed.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Verifies whether `document` is a valid root DID document according to the IOTA DID method
    * specification.
    *
    * It must be signed using a verification method with a public key whose BLAKE2b-256 hash matches
    * the DID tag.
    * @param {Document} document
    */
    static verifyRootDocument(document) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, Document);
            wasm.document_verifyRootDocument(retptr, document.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Generate a `DiffMessage` between two DID Documents and sign it using the specified
    * `key` and `method`.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {Document} other
    * @param {string} message_id
    * @param {KeyPair} key
    * @param {DIDUrl | string} method_query
    * @returns {DiffMessage}
    */
    diff(other, message_id, key, method_query) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(other, Document);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(key, KeyPair);
            wasm.document_diff(retptr, this.ptr, other.ptr, ptr0, len0, key.ptr, addBorrowedObject(method_query));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DiffMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Verifies the signature of the `diff` was created using a capability invocation method
    * in this DID Document.
    *
    * # Errors
    *
    * Fails if an unsupported verification method is used or the verification operation fails.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {DiffMessage} diff
    */
    verifyDiff(diff) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(diff, DiffMessage);
            wasm.document_verifyDiff(retptr, this.ptr, diff.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Verifies a `DiffMessage` signature and attempts to merge the changes into `self`.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {DiffMessage} diff
    */
    mergeDiff(diff) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(diff, DiffMessage);
            wasm.document_mergeDiff(retptr, this.ptr, diff.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the Tangle index of the integration chain for this DID.
    *
    * This is simply the tag segment of the `DID`.
    * E.g.
    * For a document with DID: did:iota:1234567890abcdefghijklmnopqrstuvxyzABCDEFGHI,
    * `doc.integration_index()` == "1234567890abcdefghijklmnopqrstuvxyzABCDEFGHI"
    * @returns {string}
    */
    integrationIndex() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_integrationIndex(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns the Tangle index of the DID diff chain. This should only be called on documents
    * published on the integration chain.
    *
    * This is the Base58-btc encoded SHA-256 digest of the hex-encoded message id.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {string} message_id
    * @returns {string}
    */
    static diffIndex(message_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.document_diffIndex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * Returns a copy of the metadata associated with this document.
    *
    * NOTE: Copies all the metadata. See also `metadataCreated`, `metadataUpdated`,
    * `metadataPreviousMessageId`, `metadataProof` if only a subset of the metadata required.
    * @returns {DocumentMetadata}
    */
    metadata() {
        const ret = wasm.document_metadata(this.ptr);
        return DocumentMetadata.__wrap(ret);
    }
    /**
    * Returns a copy of the timestamp of when the DID document was created.
    * @returns {Timestamp | undefined}
    */
    metadataCreated() {
        const ret = wasm.document_metadataCreated(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Sets the timestamp of when the DID document was created.
    * @param {Timestamp | undefined} timestamp
    */
    setMetadataCreated(timestamp) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_setMetadataCreated(retptr, this.ptr, addHeapObject(timestamp));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the timestamp of the last DID document update.
    * @returns {Timestamp | undefined}
    */
    metadataUpdated() {
        const ret = wasm.document_metadataUpdated(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Sets the timestamp of the last DID document update.
    * @param {Timestamp | undefined} timestamp
    */
    setMetadataUpdated(timestamp) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_setMetadataUpdated(retptr, this.ptr, addHeapObject(timestamp));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the previous integration chain message id.
    * @returns {string}
    */
    metadataPreviousMessageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_metadataPreviousMessageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Sets the previous integration chain message id.
    * @param {string} value
    */
    setMetadataPreviousMessageId(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.document_setMetadataPreviousMessageId(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the proof.
    * @returns {Proof | undefined}
    */
    proof() {
        const ret = wasm.document_proof(this.ptr);
        return ret === 0 ? undefined : Proof.__wrap(ret);
    }
    /**
    * If the document has a `RevocationBitmap` service identified by `fragment`,
    * revoke all credentials with a revocationBitmapIndex in `credentialIndices`.
    * @param {string} fragment
    * @param {number | number[]} credentialIndices
    */
    revokeCredentials(fragment, credentialIndices) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.document_revokeCredentials(retptr, this.ptr, ptr0, len0, addHeapObject(credentialIndices));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * If the document has a `RevocationBitmap` service identified by `fragment`,
    * unrevoke all credentials with a revocationBitmapIndex in `credentialIndices`.
    * @param {string} fragment
    * @param {number | number[]} credentialIndices
    */
    unrevokeCredentials(fragment, credentialIndices) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.document_unrevokeCredentials(retptr, this.ptr, ptr0, len0, addHeapObject(credentialIndices));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Document` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Document` from a JSON object.
    * @param {any} json
    * @returns {Document}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.document_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Document.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Document}
    */
    clone() {
        const ret = wasm.document_clone(this.ptr);
        return Document.__wrap(ret);
    }
}
module.exports.Document = Document;

const DocumentHistoryFinalization = new FinalizationRegistry(ptr => wasm.__wbg_documenthistory_free(ptr));
/**
* A DID Document's history and current state.
*/
class DocumentHistory {

    static __wrap(ptr) {
        const obj = Object.create(DocumentHistory.prototype);
        obj.ptr = ptr;
        DocumentHistoryFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DocumentHistoryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documenthistory_free(ptr);
    }
    /**
    * Returns an `Array` of integration chain `Documents`.
    *
    * NOTE: clones the data.
    * @returns {Array<ResolvedDocument>}
    */
    integrationChainData() {
        const ret = wasm.documenthistory_integrationChainData(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns an `Array` of message id strings for "spam" messages on the same index
    * as the integration chain.
    *
    * NOTE: clones the data.
    * @returns {Array<string>}
    */
    integrationChainSpam() {
        const ret = wasm.documenthistory_integrationChainSpam(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns an `Array` of diff chain `DiffMessages`.
    *
    * NOTE: clones the data.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {Array<DiffMessage>}
    */
    diffChainData() {
        const ret = wasm.documenthistory_diffChainData(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns an `Array` of message id strings for "spam" messages on the same index
    * as the diff chain.
    *
    * NOTE: clones the data.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {Array<string>}
    */
    diffChainSpam() {
        const ret = wasm.documenthistory_diffChainSpam(this.ptr);
        return takeObject(ret);
    }
    /**
    * Serializes `DocumentHistory` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.documenthistory_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `DocumentHistory` from a JSON object.
    * @param {any} json
    * @returns {DocumentHistory}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.documenthistory_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DocumentHistory.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {DocumentHistory}
    */
    clone() {
        const ret = wasm.documenthistory_clone(this.ptr);
        return DocumentHistory.__wrap(ret);
    }
}
module.exports.DocumentHistory = DocumentHistory;

const DocumentMetadataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_documentmetadata_free(ptr));
/**
* Additional attributes related to an IOTA DID Document.
*/
class DocumentMetadata {

    static __wrap(ptr) {
        const obj = Object.create(DocumentMetadata.prototype);
        obj.ptr = ptr;
        DocumentMetadataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            previousMessageId: this.previousMessageId,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DocumentMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_documentmetadata_free(ptr);
    }
    /**
    * Returns a copy of the timestamp of when the DID document was created.
    * @returns {Timestamp | undefined}
    */
    created() {
        const ret = wasm.documentmetadata_created(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Returns a copy of the timestamp of the last DID document update.
    * @returns {Timestamp | undefined}
    */
    updated() {
        const ret = wasm.documentmetadata_updated(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    */
    get previousMessageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.documentmetadata_previous_message_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Deep clones the object.
    * @returns {DocumentMetadata}
    */
    clone() {
        const ret = wasm.documentmetadata_clone(this.ptr);
        return DocumentMetadata.__wrap(ret);
    }
}
module.exports.DocumentMetadata = DocumentMetadata;

const DurationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_duration_free(ptr));
/**
* A span of time.
*/
class Duration {

    static __wrap(ptr) {
        const obj = Object.create(Duration.prototype);
        obj.ptr = ptr;
        DurationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DurationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_duration_free(ptr);
    }
    /**
    * Create a new `Duration` with the given number of seconds.
    * @param {number} seconds
    * @returns {Duration}
    */
    static seconds(seconds) {
        const ret = wasm.duration_seconds(seconds);
        return Duration.__wrap(ret);
    }
    /**
    * Create a new `Duration` with the given number of minutes.
    * @param {number} minutes
    * @returns {Duration}
    */
    static minutes(minutes) {
        const ret = wasm.duration_minutes(minutes);
        return Duration.__wrap(ret);
    }
    /**
    * Create a new `Duration` with the given number of hours.
    * @param {number} hours
    * @returns {Duration}
    */
    static hours(hours) {
        const ret = wasm.duration_hours(hours);
        return Duration.__wrap(ret);
    }
    /**
    * Create a new `Duration` with the given number of days.
    * @param {number} days
    * @returns {Duration}
    */
    static days(days) {
        const ret = wasm.duration_days(days);
        return Duration.__wrap(ret);
    }
    /**
    * Create a new `Duration` with the given number of weeks.
    * @param {number} weeks
    * @returns {Duration}
    */
    static weeks(weeks) {
        const ret = wasm.duration_weeks(weeks);
        return Duration.__wrap(ret);
    }
    /**
    * Serializes a `Duration` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.duration_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Duration` from a JSON object.
    * @param {any} json
    * @returns {Duration}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.duration_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Duration.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.Duration = Duration;

const Ed25519Finalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519_free(ptr));
/**
*/
class Ed25519 {

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519_free(ptr);
    }
    /**
    * Length in bytes of an Ed25519 private key.
    * @returns {number}
    */
    static PRIVATE_KEY_LENGTH() {
        const ret = wasm.ed25519_PRIVATE_KEY_LENGTH();
        return ret >>> 0;
    }
    /**
    * Length in bytes of an Ed25519 public key.
    * @returns {number}
    */
    static PUBLIC_KEY_LENGTH() {
        const ret = wasm.ed25519_PUBLIC_KEY_LENGTH();
        return ret >>> 0;
    }
    /**
    * Length in bytes of an Ed25519 signature.
    * @returns {number}
    */
    static SIGNATURE_LENGTH() {
        const ret = wasm.ed25519_SIGNATURE_LENGTH();
        return ret >>> 0;
    }
    /**
    * Computes an EdDSA signature using an Ed25519 private key.
    *
    * NOTE: this differs from {@link Document.signData} which uses JCS
    * to canonicalize JSON messages.
    *
    * The private key must be a 32-byte seed in compliance with [RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032#section-3.2).
    * Other implementations often use another format. See [this blog post](https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/) for further explanation.
    * @param {Uint8Array} message
    * @param {Uint8Array} privateKey
    * @returns {Uint8Array}
    */
    static sign(message, privateKey) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.ed25519_sign(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v2 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Verifies an EdDSA signature against an Ed25519 public key.
    *
    * NOTE: this differs from {@link Document.verifyData} which uses JCS
    * to canonicalize JSON messages.
    * @param {Uint8Array} message
    * @param {Uint8Array} signature
    * @param {Uint8Array} publicKey
    */
    static verify(message, signature, publicKey) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN;
            const ptr2 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
            const len2 = WASM_VECTOR_LEN;
            wasm.ed25519_verify(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Ed25519 = Ed25519;

const EncryptedDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_encrypteddata_free(ptr));
/**
* The structure returned after encrypting data
*/
class EncryptedData {

    static __wrap(ptr) {
        const obj = Object.create(EncryptedData.prototype);
        obj.ptr = ptr;
        EncryptedDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EncryptedDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encrypteddata_free(ptr);
    }
    /**
    * Returns a copy of the nonce
    * @returns {Uint8Array}
    */
    nonce() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_nonce(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the associated data
    * @returns {Uint8Array}
    */
    associatedData() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_associatedData(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the ciphertext
    * @returns {Uint8Array}
    */
    ciphertext() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_ciphertext(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the tag
    * @returns {Uint8Array}
    */
    tag() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_tag(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes `EncryptedData` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `EncryptedData` from a JSON object.
    * @param {any} json_value
    * @returns {EncryptedData}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encrypteddata_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.EncryptedData = EncryptedData;

const EncryptionAlgorithmFinalization = new FinalizationRegistry(ptr => wasm.__wbg_encryptionalgorithm_free(ptr));
/**
* Supported content encryption algorithms.
*/
class EncryptionAlgorithm {

    static __wrap(ptr) {
        const obj = Object.create(EncryptionAlgorithm.prototype);
        obj.ptr = ptr;
        EncryptionAlgorithmFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EncryptionAlgorithmFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encryptionalgorithm_free(ptr);
    }
    /**
    * AES GCM using 256-bit key.
    * @returns {EncryptionAlgorithm}
    */
    static A256GCM() {
        const ret = wasm.encryptionalgorithm_A256GCM();
        return EncryptionAlgorithm.__wrap(ret);
    }
    /**
    * Returns the length of the cipher's key.
    * @returns {number}
    */
    keyLength() {
        const ret = wasm.encryptionalgorithm_keyLength(this.ptr);
        return ret >>> 0;
    }
    /**
    * Serializes `EncryptionAlgorithm` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptionalgorithm_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `EncryptionAlgorithm` from a JSON object.
    * @param {any} json_value
    * @returns {EncryptionAlgorithm}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptionalgorithm_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptionAlgorithm.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.EncryptionAlgorithm = EncryptionAlgorithm;

const ExplorerUrlFinalization = new FinalizationRegistry(ptr => wasm.__wbg_explorerurl_free(ptr));
/**
*/
class ExplorerUrl {

    static __wrap(ptr) {
        const obj = Object.create(ExplorerUrl.prototype);
        obj.ptr = ptr;
        ExplorerUrlFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ExplorerUrlFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_explorerurl_free(ptr);
    }
    /**
    * Constructs a new Tangle explorer URL from a string.
    *
    * Use `ExplorerUrl::mainnet` or `ExplorerUrl::devnet` unless using a private Tangle
    * or local explorer.
    * @param {string} url
    * @returns {ExplorerUrl}
    */
    static parse(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.explorerurl_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ExplorerUrl.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the Tangle explorer URL for the mainnet.
    * @returns {ExplorerUrl}
    */
    static mainnet() {
        const ret = wasm.explorerurl_mainnet();
        return ExplorerUrl.__wrap(ret);
    }
    /**
    * Returns the Tangle explorer URL for the devnet.
    * @returns {ExplorerUrl}
    */
    static devnet() {
        const ret = wasm.explorerurl_devnet();
        return ExplorerUrl.__wrap(ret);
    }
    /**
    * Returns the web explorer URL of the given `message_id`.
    *
    * E.g. https://explorer.iota.org/mainnet/message/{message_id}
    * @param {string} message_id
    * @returns {string}
    */
    messageUrl(message_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(message_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.explorerurl_messageUrl(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr1, len1);
        }
    }
    /**
    * Returns the web identity resolver URL for the given DID.
    *
    * E.g. https://explorer.iota.org/mainnet/identity-resolver/{did}
    * @param {DID | string} did
    * @returns {string}
    */
    resolverUrl(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.explorerurl_resolverUrl(retptr, this.ptr, addHeapObject(did));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.explorerurl_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.ExplorerUrl = ExplorerUrl;

const IntegrationChainHistoryFinalization = new FinalizationRegistry(ptr => wasm.__wbg_integrationchainhistory_free(ptr));
/**
*/
class IntegrationChainHistory {

    static __wrap(ptr) {
        const obj = Object.create(IntegrationChainHistory.prototype);
        obj.ptr = ptr;
        IntegrationChainHistoryFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        IntegrationChainHistoryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_integrationchainhistory_free(ptr);
    }
    /**
    * Returns an `Array` of the integration chain `Documents`.
    *
    * NOTE: this clones the field.
    * @returns {Array<ResolvedDocument>}
    */
    chainData() {
        const ret = wasm.integrationchainhistory_chainData(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns an `Array` of `MessageIds` as strings.
    *
    * NOTE: this clones the field.
    * @returns {Array<string>}
    */
    spam() {
        const ret = wasm.integrationchainhistory_spam(this.ptr);
        return takeObject(ret);
    }
    /**
    * Serializes as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.integrationchainhistory_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes from a JSON object.
    * @param {any} json
    * @returns {IntegrationChainHistory}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.integrationchainhistory_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return IntegrationChainHistory.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.IntegrationChainHistory = IntegrationChainHistory;

const KeyLocationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keylocation_free(ptr));
/**
* The storage location of a verification method key.
*
* A key is uniquely identified by the fragment and a hash of its public key.
* Importantly, the fragment alone is insufficient to represent the storage location.
* For example, when rotating a key, there will be two keys in storage for the
* same identity with the same fragment. The `key_hash` disambiguates the keys in
* situations like these.
*
* The string representation of that location can be obtained via `canonicalRepr`.
*/
class KeyLocation {

    static __wrap(ptr) {
        const obj = Object.create(KeyLocation.prototype);
        obj.ptr = ptr;
        KeyLocationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeyLocationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keylocation_free(ptr);
    }
    /**
    * Create a location from a `KeyType`, the fragment of a verification method
    * and the bytes of a public key.
    * @param {number} keyType
    * @param {string} fragment
    * @param {Uint8Array} publicKey
    */
    constructor(keyType, fragment, publicKey) {
        const ptr0 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.keylocation_new(keyType, ptr0, len0, ptr1, len1);
        return KeyLocation.__wrap(ret);
    }
    /**
    * Obtain the location of a verification method's key in storage.
    * @param {VerificationMethod} method
    * @returns {KeyLocation}
    */
    static fromVerificationMethod(method) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(method, VerificationMethod);
            wasm.keylocation_fromVerificationMethod(retptr, method.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyLocation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the canonical string representation of the location.
    *
    * This should be used as the representation for storage keys.
    * @returns {string}
    */
    canonical() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keylocation_canonical(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the key type of the key location.
    * @returns {number}
    */
    keyType() {
        const ret = wasm.keylocation_keyType(this.ptr);
        return ret >>> 0;
    }
    /**
    * Serializes `KeyLocation` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keylocation_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a JSON object into a `KeyLocation`.
    * @param {any} json_value
    * @returns {KeyLocation}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keylocation_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyLocation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keylocation_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.KeyLocation = KeyLocation;

const KeyPairFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keypair_free(ptr));
/**
*/
class KeyPair {

    static __wrap(ptr) {
        const obj = Object.create(KeyPair.prototype);
        obj.ptr = ptr;
        KeyPairFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeyPairFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keypair_free(ptr);
    }
    /**
    * Generates a new `KeyPair` object.
    * @param {number} type_
    */
    constructor(type_) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keypair_new(retptr, type_);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyPair.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Parses a `KeyPair` object from the public/private keys.
    * @param {number} type_
    * @param {Uint8Array} public_key
    * @param {Uint8Array} private_key
    * @returns {KeyPair}
    */
    static fromKeys(type_, public_key, private_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.keypair_fromKeys(retptr, type_, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyPair.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Reconstructs a `KeyPair` from the bytes of a private key.
    *
    * The private key for `Ed25519` must be a 32-byte seed in compliance
    * with [RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032#section-3.2).
    * Other implementations often use another format. See [this blog post](https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/) for further explanation.
    * @param {number} keyType
    * @param {Uint8Array} privateKeyBytes
    * @returns {KeyPair}
    */
    static tryFromPrivateKeyBytes(keyType, privateKeyBytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(privateKeyBytes, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.keypair_tryFromPrivateKeyBytes(retptr, keyType, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyPair.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the `KeyType` of the `KeyPair` object.
    * @returns {number}
    */
    type() {
        const ret = wasm.keypair_type(this.ptr);
        return ret >>> 0;
    }
    /**
    * Returns a copy of the public key as a `Uint8Array`.
    * @returns {Uint8Array}
    */
    public() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keypair_public(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the private key as a `Uint8Array`.
    * @returns {Uint8Array}
    */
    private() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keypair_private(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `KeyPair` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keypair_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `KeyPair` object from a JSON object.
    * @param {any} json
    * @returns {KeyPair}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keypair_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return KeyPair.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {KeyPair}
    */
    clone() {
        const ret = wasm.keypair_clone(this.ptr);
        return KeyPair.__wrap(ret);
    }
}
module.exports.KeyPair = KeyPair;

const MethodContentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_methodcontent_free(ptr));
/**
*/
class MethodContent {

    static __wrap(ptr) {
        const obj = Object.create(MethodContent.prototype);
        obj.ptr = ptr;
        MethodContentFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MethodContentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_methodcontent_free(ptr);
    }
    /**
    * Generate and store a new Ed25519 keypair for a new `Ed25519VerificationKey2018` method.
    * @returns {MethodContent}
    */
    static GenerateEd25519() {
        const ret = wasm.methodcontent_GenerateEd25519();
        return MethodContent.__wrap(ret);
    }
    /**
    * Store an existing Ed25519 private key and derive a public key from it for a new
    * `Ed25519VerificationKey2018` method.
    * @param {Uint8Array} privateKey
    * @returns {MethodContent}
    */
    static PrivateEd25519(privateKey) {
        const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methodcontent_PrivateEd25519(ptr0, len0);
        return MethodContent.__wrap(ret);
    }
    /**
    * Insert an existing Ed25519 public key into a new `Ed25519VerificationKey2018` method,
    * without generating or storing a private key.
    *
    * NOTE: the method will be unable to be used to sign anything without a private key.
    * @param {Uint8Array} publicKey
    * @returns {MethodContent}
    */
    static PublicEd25519(publicKey) {
        const ptr0 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methodcontent_PublicEd25519(ptr0, len0);
        return MethodContent.__wrap(ret);
    }
    /**
    * Generate and store a new X25519 keypair for a new `X25519KeyAgreementKey2019` method.
    * @returns {MethodContent}
    */
    static GenerateX25519() {
        const ret = wasm.methodcontent_GenerateX25519();
        return MethodContent.__wrap(ret);
    }
    /**
    * Store an existing X25519 private key and derive a public key from it for a new
    * `X25519KeyAgreementKey2019` method.
    * @param {Uint8Array} privateKey
    * @returns {MethodContent}
    */
    static PrivateX25519(privateKey) {
        const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methodcontent_PrivateX25519(ptr0, len0);
        return MethodContent.__wrap(ret);
    }
    /**
    * Insert an existing X25519 public key into a new `X25519KeyAgreementKey2019` method,
    * without generating or storing a private key.
    *
    * NOTE: the method will be unable to be used for key exchange without a private key.
    * @param {Uint8Array} publicKey
    * @returns {MethodContent}
    */
    static PublicX25519(publicKey) {
        const ptr0 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methodcontent_PublicX25519(ptr0, len0);
        return MethodContent.__wrap(ret);
    }
    /**
    * Serializes `MethodContent` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodcontent_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes `MethodContent` from a JSON object.
    * @param {any} json_value
    * @returns {MethodContent}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodcontent_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MethodContent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.MethodContent = MethodContent;

const MethodDataFinalization = new FinalizationRegistry(ptr => wasm.__wbg_methoddata_free(ptr));
/**
* Supported verification method data formats.
*/
class MethodData {

    static __wrap(ptr) {
        const obj = Object.create(MethodData.prototype);
        obj.ptr = ptr;
        MethodDataFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MethodDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_methoddata_free(ptr);
    }
    /**
    * Creates a new `MethodData` variant with Base58-BTC encoded content.
    * @param {Uint8Array} data
    * @returns {MethodData}
    */
    static newBase58(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methoddata_newBase58(ptr0, len0);
        return MethodData.__wrap(ret);
    }
    /**
    * Creates a new `MethodData` variant with Multibase-encoded content.
    * @param {Uint8Array} data
    * @returns {MethodData}
    */
    static newMultibase(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.methoddata_newMultibase(ptr0, len0);
        return MethodData.__wrap(ret);
    }
    /**
    * Returns a `Uint8Array` containing the decoded bytes of the `MethodData`.
    *
    * This is generally a public key identified by a `MethodData` value.
    *
    * ### Errors
    * Decoding can fail if `MethodData` has invalid content or cannot be
    * represented as a vector of bytes.
    * @returns {Uint8Array}
    */
    tryDecode() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methoddata_tryDecode(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `MethodData` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methoddata_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `MethodData` object from a JSON object.
    * @param {any} json
    * @returns {MethodData}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methoddata_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MethodData.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {MethodData}
    */
    clone() {
        const ret = wasm.methoddata_clone(this.ptr);
        return MethodData.__wrap(ret);
    }
}
module.exports.MethodData = MethodData;

const MethodScopeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_methodscope_free(ptr));
/**
* Supported verification method types.
*/
class MethodScope {

    static __wrap(ptr) {
        const obj = Object.create(MethodScope.prototype);
        obj.ptr = ptr;
        MethodScopeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MethodScopeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_methodscope_free(ptr);
    }
    /**
    * @returns {MethodScope}
    */
    static VerificationMethod() {
        const ret = wasm.methodscope_VerificationMethod();
        return MethodScope.__wrap(ret);
    }
    /**
    * @returns {MethodScope}
    */
    static Authentication() {
        const ret = wasm.methodscope_Authentication();
        return MethodScope.__wrap(ret);
    }
    /**
    * @returns {MethodScope}
    */
    static AssertionMethod() {
        const ret = wasm.methodscope_AssertionMethod();
        return MethodScope.__wrap(ret);
    }
    /**
    * @returns {MethodScope}
    */
    static KeyAgreement() {
        const ret = wasm.methodscope_KeyAgreement();
        return MethodScope.__wrap(ret);
    }
    /**
    * @returns {MethodScope}
    */
    static CapabilityDelegation() {
        const ret = wasm.methodscope_CapabilityDelegation();
        return MethodScope.__wrap(ret);
    }
    /**
    * @returns {MethodScope}
    */
    static CapabilityInvocation() {
        const ret = wasm.methodscope_CapabilityInvocation();
        return MethodScope.__wrap(ret);
    }
    /**
    * Returns the `MethodScope` as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodscope_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Serializes a `MethodScope` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodscope_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `MethodScope` object from a JSON object.
    * @param {any} json
    * @returns {MethodScope}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodscope_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MethodScope.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {MethodScope}
    */
    clone() {
        const ret = wasm.methodscope_clone(this.ptr);
        return MethodScope.__wrap(ret);
    }
}
module.exports.MethodScope = MethodScope;

const MethodTypeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_methodtype_free(ptr));
/**
* Supported verification method types.
*/
class MethodType {

    static __wrap(ptr) {
        const obj = Object.create(MethodType.prototype);
        obj.ptr = ptr;
        MethodTypeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MethodTypeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_methodtype_free(ptr);
    }
    /**
    * @returns {MethodType}
    */
    static Ed25519VerificationKey2018() {
        const ret = wasm.methodtype_Ed25519VerificationKey2018();
        return MethodType.__wrap(ret);
    }
    /**
    * @returns {MethodType}
    */
    static X25519KeyAgreementKey2019() {
        const ret = wasm.methodtype_X25519KeyAgreementKey2019();
        return MethodType.__wrap(ret);
    }
    /**
    * Serializes a `MethodType` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodtype_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `MethodType` object from a JSON object.
    * @param {any} json
    * @returns {MethodType}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodtype_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return MethodType.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Returns the `MethodType` as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.methodtype_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Deep clones the object.
    * @returns {MethodType}
    */
    clone() {
        const ret = wasm.methodtype_clone(this.ptr);
        return MethodType.__wrap(ret);
    }
}
module.exports.MethodType = MethodType;

const NetworkFinalization = new FinalizationRegistry(ptr => wasm.__wbg_network_free(ptr));
/**
*/
class Network {

    static __wrap(ptr) {
        const obj = Object.create(Network.prototype);
        obj.ptr = ptr;
        NetworkFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        NetworkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_network_free(ptr);
    }
    /**
    * Parses the provided string to a `Network`.
    *
    * Errors if the name is invalid.
    * @param {string} name
    * @returns {Network}
    */
    static tryFromName(name) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.network_tryFromName(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Network.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Network}
    */
    static mainnet() {
        const ret = wasm.network_mainnet();
        return Network.__wrap(ret);
    }
    /**
    * @returns {Network}
    */
    static devnet() {
        const ret = wasm.network_devnet();
        return Network.__wrap(ret);
    }
    /**
    * Returns a copy of the network name.
    * @returns {string}
    */
    name() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.network_name(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the node URL of the Tangle network.
    * @returns {string | undefined}
    */
    defaultNodeURL() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.network_defaultNodeURL(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.network_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Serializes a `Network` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.network_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Network` from a JSON object.
    * @param {any} json
    * @returns {Network}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.network_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Network.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Network}
    */
    clone() {
        const ret = wasm.network_clone(this.ptr);
        return Network.__wrap(ret);
    }
}
module.exports.Network = Network;

const PresentationFinalization = new FinalizationRegistry(ptr => wasm.__wbg_presentation_free(ptr));
/**
*/
class Presentation {

    static __wrap(ptr) {
        const obj = Object.create(Presentation.prototype);
        obj.ptr = ptr;
        PresentationFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PresentationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_presentation_free(ptr);
    }
    /**
    * Returns the base JSON-LD context.
    * @returns {string}
    */
    static BaseContext() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_BaseContext(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * Returns the base type.
    * @returns {string}
    */
    static BaseType() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_BaseType(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Constructs a new `Presentation`.
    * @param {IPresentation} values
    */
    constructor(values) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_new(retptr, addHeapObject(values));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Presentation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the JSON-LD context(s) applicable to the `Presentation`.
    * @returns {Array<string | Record<string, any>>}
    */
    context() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_context(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the unique `URI` identifying the `Presentation`.
    * @returns {string | undefined}
    */
    id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the URIs defining the type of the `Presentation`.
    * @returns {Array<string>}
    */
    type() {
        const ret = wasm.presentation_type(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns a copy of the {@link Credential}(s) expressing the claims of the `Presentation`.
    * @returns {Array<Credential>}
    */
    verifiableCredential() {
        const ret = wasm.presentation_verifiableCredential(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns a copy of the URI of the entity that generated the `Presentation`.
    * @returns {string | undefined}
    */
    holder() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_holder(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the service(s) used to refresh an expired {@link Credential} in the `Presentation`.
    * @returns {Array<RefreshService>}
    */
    refreshService() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_refreshService(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the terms-of-use specified by the `Presentation` holder
    * @returns {Array<Policy>}
    */
    termsOfUse() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_termsOfUse(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the proof used to verify the `Presentation`.
    * @returns {Proof | undefined}
    */
    proof() {
        const ret = wasm.presentation_proof(this.ptr);
        return ret === 0 ? undefined : Proof.__wrap(ret);
    }
    /**
    * Returns a copy of the miscellaneous properties on the `Presentation`.
    * @returns {Map<string, any>}
    */
    properties() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_properties(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Presentation` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Presentation` from a JSON object.
    * @param {any} json
    * @returns {Presentation}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentation_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Presentation.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Presentation}
    */
    clone() {
        const ret = wasm.presentation_clone(this.ptr);
        return Presentation.__wrap(ret);
    }
}
module.exports.Presentation = Presentation;

const PresentationValidationOptionsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_presentationvalidationoptions_free(ptr));
/**
* Options to declare validation criteria when validating presentation.
*/
class PresentationValidationOptions {

    static __wrap(ptr) {
        const obj = Object.create(PresentationValidationOptions.prototype);
        obj.ptr = ptr;
        PresentationValidationOptionsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PresentationValidationOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_presentationvalidationoptions_free(ptr);
    }
    /**
    * Creates a new `PresentationValidationOptions` from the given fields.
    *
    * Throws an error if any of the options are invalid.
    * @param {IPresentationValidationOptions} options
    */
    constructor(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentationvalidationoptions_new(retptr, addHeapObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PresentationValidationOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `PresentationValidationOptions` with defaults.
    * @returns {PresentationValidationOptions}
    */
    static default() {
        const ret = wasm.presentationvalidationoptions_default();
        return PresentationValidationOptions.__wrap(ret);
    }
    /**
    * Serializes a `PresentationValidationOptions` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentationvalidationoptions_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `PresentationValidationOptions` from a JSON object.
    * @param {any} json
    * @returns {PresentationValidationOptions}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.presentationvalidationoptions_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PresentationValidationOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {PresentationValidationOptions}
    */
    clone() {
        const ret = wasm.presentationvalidationoptions_clone(this.ptr);
        return PresentationValidationOptions.__wrap(ret);
    }
}
module.exports.PresentationValidationOptions = PresentationValidationOptions;

const PresentationValidatorFinalization = new FinalizationRegistry(ptr => wasm.__wbg_presentationvalidator_free(ptr));
/**
*/
class PresentationValidator {

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        PresentationValidatorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_presentationvalidator_free(ptr);
    }
    /**
    * Validate a `Presentation`.
    *
    * The following properties are validated according to `options`:
    * - the semantic structure of the presentation,
    * - the holder's signature,
    * - the relationship between the holder and the credential subjects,
    * - the signatures and some properties of the constituent credentials (see
    * `CredentialValidator::validate`).
    *
    * ### Warning
    * The lack of an error returned from this method is in of itself not enough to conclude that the presentation can be
    * trusted. This section contains more information on additional checks that should be carried out before and after
    * calling this method.
    *
    * #### The state of the supplied DID Documents.
    * The caller must ensure that the DID Documents in `holder` and `issuers` are up-to-date. The convenience methods
    * `Resolver::resolve_presentation_holder` and `Resolver::resolve_presentation_issuers`
    * can help extract the latest available states of these DID Documents.
    *
    * #### Properties that are not validated
    *  There are many properties defined in [The Verifiable Credentials Data Model](https://www.w3.org/TR/vc-data-model/) that are **not** validated, such as:
    * `credentialStatus`, `type`, `credentialSchema`, `refreshService`, **and more**.
    * These should be manually checked after validation, according to your requirements.
    *
    * ### Errors
    * An error is returned whenever a validated condition is not satisfied.
    * @param {Presentation} presentation
    * @param {Document | ResolvedDocument} holder
    * @param {Array<Document> | Array<ResolvedDocument>} issuers
    * @param {PresentationValidationOptions} options
    * @param {number} fail_fast
    */
    static validate(presentation, holder, issuers, options, fail_fast) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            _assertClass(options, PresentationValidationOptions);
            wasm.presentationvalidator_validate(retptr, presentation.ptr, addBorrowedObject(holder), addBorrowedObject(issuers), options.ptr, fail_fast);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Verify the presentation's signature using the resolved document of the holder.
    *
    * ### Warning
    * The caller must ensure that the DID Document of the holder is up-to-date.
    *
    * ### Errors
    * Fails if the `holder` does not match the `presentation`'s holder property.
    * Fails if signature verification against the holder document fails.
    * @param {Presentation} presentation
    * @param {Document | ResolvedDocument} holder
    * @param {VerifierOptions} options
    */
    static verifyPresentationSignature(presentation, holder, options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            _assertClass(options, VerifierOptions);
            wasm.presentationvalidator_verifyPresentationSignature(retptr, presentation.ptr, addBorrowedObject(holder), options.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Validates the semantic structure of the `Presentation`.
    * @param {Presentation} presentation
    */
    static checkStructure(presentation) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            wasm.presentationvalidator_checkStructure(retptr, presentation.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.PresentationValidator = PresentationValidator;

const ProofFinalization = new FinalizationRegistry(ptr => wasm.__wbg_proof_free(ptr));
/**
* A digital signature.
*
* For field definitions see: https://w3c-ccg.github.io/security-vocab/
*/
class Proof {

    static __wrap(ptr) {
        const obj = Object.create(Proof.prototype);
        obj.ptr = ptr;
        ProofFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProofFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proof_free(ptr);
    }
    /**
    * Returns a copy of the proof type.
    * @returns {string}
    */
    type() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_type(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the proof value string.
    * @returns {string}
    */
    value() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_value(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the identifier of the DID method used to create this proof.
    * @returns {string}
    */
    verificationMethod() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_verificationMethod(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * When the proof was generated.
    * @returns {Timestamp | undefined}
    */
    created() {
        const ret = wasm.proof_created(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * When the proof expires.
    * @returns {Timestamp | undefined}
    */
    expires() {
        const ret = wasm.proof_expires(this.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Challenge from a proof requester to mitigate replay attacks.
    * @returns {string | undefined}
    */
    challenge() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_challenge(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Domain for which a proof is valid to mitigate replay attacks.
    * @returns {string | undefined}
    */
    domain() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_domain(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Purpose for which the proof was generated.
    * @returns {ProofPurpose | undefined}
    */
    purpose() {
        const ret = wasm.proof_purpose(this.ptr);
        return ret === 0 ? undefined : ProofPurpose.__wrap(ret);
    }
    /**
    * Serializes a `Proof` to a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Proof` from a JSON object.
    * @param {any} json
    * @returns {Proof}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proof_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Proof.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Proof}
    */
    clone() {
        const ret = wasm.proof_clone(this.ptr);
        return Proof.__wrap(ret);
    }
}
module.exports.Proof = Proof;

const ProofOptionsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_proofoptions_free(ptr));
/**
* Holds additional options for creating signatures.
* See `IProofOptions`.
*/
class ProofOptions {

    static __wrap(ptr) {
        const obj = Object.create(ProofOptions.prototype);
        obj.ptr = ptr;
        ProofOptionsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProofOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proofoptions_free(ptr);
    }
    /**
    * Creates a new `ProofOptions` from the given fields.
    *
    * Throws an error if any of the options are invalid.
    * @param {IProofOptions} options
    */
    constructor(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proofoptions_new(retptr, addHeapObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProofOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `ProofOptions` with default options.
    * @returns {ProofOptions}
    */
    static default() {
        const ret = wasm.proofoptions_default();
        return ProofOptions.__wrap(ret);
    }
    /**
    * Deep clones the object.
    * @returns {ProofOptions}
    */
    clone() {
        const ret = wasm.proofoptions_clone(this.ptr);
        return ProofOptions.__wrap(ret);
    }
}
module.exports.ProofOptions = ProofOptions;

const ProofPurposeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_proofpurpose_free(ptr));
/**
* Associates a purpose with a {@link Proof}.
*
* See https://w3c-ccg.github.io/security-vocab/#proofPurpose
*/
class ProofPurpose {

    static __wrap(ptr) {
        const obj = Object.create(ProofPurpose.prototype);
        obj.ptr = ptr;
        ProofPurposeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ProofPurposeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proofpurpose_free(ptr);
    }
    /**
    * Purpose is to assert a claim.
    * See https://www.w3.org/TR/did-core/#assertion
    * @returns {ProofPurpose}
    */
    static assertionMethod() {
        const ret = wasm.proofpurpose_assertionMethod();
        return ProofPurpose.__wrap(ret);
    }
    /**
    * Purpose is to authenticate the signer.
    * See https://www.w3.org/TR/did-core/#authentication
    * @returns {ProofPurpose}
    */
    static authentication() {
        const ret = wasm.proofpurpose_authentication();
        return ProofPurpose.__wrap(ret);
    }
    /**
    * Serializes a `ProofPurpose` to a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proofpurpose_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `ProofPurpose` from a JSON object.
    * @param {any} json
    * @returns {ProofPurpose}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.proofpurpose_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ProofPurpose.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {ProofPurpose}
    */
    clone() {
        const ret = wasm.proofpurpose_clone(this.ptr);
        return ProofPurpose.__wrap(ret);
    }
}
module.exports.ProofPurpose = ProofPurpose;

const ReceiptFinalization = new FinalizationRegistry(ptr => wasm.__wbg_receipt_free(ptr));
/**
*/
class Receipt {

    static __wrap(ptr) {
        const obj = Object.create(Receipt.prototype);
        obj.ptr = ptr;
        ReceiptFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ReceiptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_receipt_free(ptr);
    }
    /**
    * Returns a copy of the associated IOTA Tangle `Network`.
    * @returns {Network}
    */
    network() {
        const ret = wasm.receipt_network(this.ptr);
        return Network.__wrap(ret);
    }
    /**
    * Returns a copy of the message `id`.
    * @returns {string}
    */
    messageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.receipt_messageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the message `network_id`.
    * @returns {string}
    */
    networkId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.receipt_networkId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the message `nonce`.
    * @returns {string}
    */
    nonce() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.receipt_nonce(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Serializes a `Receipt` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.receipt_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Receipt` from a JSON object.
    * @param {any} json
    * @returns {Receipt}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.receipt_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Receipt.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Receipt}
    */
    clone() {
        const ret = wasm.receipt_clone(this.ptr);
        return Receipt.__wrap(ret);
    }
}
module.exports.Receipt = Receipt;

const ResolvedDocumentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_resolveddocument_free(ptr));
/**
* An IOTA DID document resolved from the Tangle. Represents an integration chain message possibly
* merged with one or more `DiffMessages`.
*/
class ResolvedDocument {

    static __wrap(ptr) {
        const obj = Object.create(ResolvedDocument.prototype);
        obj.ptr = ptr;
        ResolvedDocumentFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ResolvedDocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resolveddocument_free(ptr);
    }
    /**
    * Attempts to merge changes from a `DiffMessage` into this document and
    * updates the `ResolvedDocument::diffMessageId`.
    *
    * If merging fails the document remains unmodified, otherwise this represents
    * the merged document state.
    *
    * See `Document::mergeDiff`.
    *
    * # Errors
    *
    * Fails if the merge operation or signature verification on the diff fails.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {DiffMessage} diff_message
    */
    mergeDiffMessage(diff_message) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(diff_message, DiffMessage);
            wasm.resolveddocument_mergeDiffMessage(retptr, this.ptr, diff_message.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the inner DID document.
    *
    * NOTE: If the `ResolvedDocument` is no longer needed after calling this method
    * then consider using `intoDocument()` for efficiency.
    * @returns {Document}
    */
    document() {
        const ret = wasm.resolveddocument_document(this.ptr);
        return Document.__wrap(ret);
    }
    /**
    * Consumes this object and returns the inner DID document.
    *
    * NOTE: trying to use the `ResolvedDocument` after calling this will throw an error.
    * @returns {Document}
    */
    intoDocument() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.resolveddocument_intoDocument(ptr);
        return Document.__wrap(ret);
    }
    /**
    * Returns a copy of the diff chain message id.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @returns {string}
    */
    diffMessageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolveddocument_diffMessageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Sets the diff chain message id.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {string} value
    */
    setDiffMessageId(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.resolveddocument_setDiffMessageId(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the integration chain message id.
    * @returns {string}
    */
    integrationMessageId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolveddocument_integrationMessageId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Sets the integration chain message id.
    * @param {string} value
    */
    setIntegrationMessageId(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.resolveddocument_setIntegrationMessageId(retptr, this.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Document` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolveddocument_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Document` object from a JSON object.
    * @param {any} json
    * @returns {ResolvedDocument}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolveddocument_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ResolvedDocument.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {ResolvedDocument}
    */
    clone() {
        const ret = wasm.resolveddocument_clone(this.ptr);
        return ResolvedDocument.__wrap(ret);
    }
}
module.exports.ResolvedDocument = ResolvedDocument;

const ResolverFinalization = new FinalizationRegistry(ptr => wasm.__wbg_resolver_free(ptr));
/**
*/
class Resolver {

    static __wrap(ptr) {
        const obj = Object.create(Resolver.prototype);
        obj.ptr = ptr;
        ResolverFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ResolverFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resolver_free(ptr);
    }
    /**
    * Constructs a new `Resolver` with a default `Client` for
    * the `Mainnet`.
    */
    constructor() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolver_new(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Resolver.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a {@link ResolverBuilder} to construct a new `Resolver`.
    * @returns {ResolverBuilder}
    */
    static builder() {
        const ret = wasm.resolver_builder();
        return ResolverBuilder.__wrap(ret);
    }
    /**
    * Returns the `Client` corresponding to the given network name if one exists.
    * @param {string} network_name
    * @returns {Client | undefined}
    */
    getClient(network_name) {
        const ptr0 = passStringToWasm0(network_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.resolver_getClient(this.ptr, ptr0, len0);
        return ret === 0 ? undefined : Client.__wrap(ret);
    }
    /**
    * Fetches the `Document` of the given `DID`.
    * @param {DID | string} did
    * @returns {Promise<ResolvedDocument>}
    */
    resolve(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolver_resolve(retptr, this.ptr, addHeapObject(did));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Fetches the `DocumentHistory` of the given `DID`.
    * @param {DID | string} did
    * @returns {Promise<DocumentHistory>}
    */
    resolveHistory(did) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolver_resolveHistory(retptr, this.ptr, addHeapObject(did));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the `DiffChainHistory` of a diff chain starting from a `Document` on the
    * integration chain.
    *
    * NOTE: the document must have been published to the Tangle and have a valid message id.
    *
    * @deprecated since 0.5.0, diff chain features are slated for removal.
    * @param {ResolvedDocument} document
    * @returns {Promise<DiffChainHistory>}
    */
    resolveDiffHistory(document) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(document, ResolvedDocument);
            wasm.resolver_resolveDiffHistory(retptr, this.ptr, document.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Fetches the DID Document of the issuer on a `Credential`.
    *
    * ### Errors
    *
    * Errors if the issuer URL is not a valid `DID` or document resolution fails.
    * @param {Credential} credential
    * @returns {Promise<ResolvedDocument>}
    */
    resolveCredentialIssuer(credential) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(credential, Credential);
            wasm.resolver_resolveCredentialIssuer(retptr, this.ptr, credential.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Fetches all DID Documents of `Credential` issuers contained in a `Presentation`.
    * Issuer documents are returned in arbitrary order.
    *
    * ### Errors
    *
    * Errors if any issuer URL is not a valid `DID` or document resolution fails.
    * @param {Presentation} presentation
    * @returns {Promise<Array<ResolvedDocument>>}
    */
    resolvePresentationIssuers(presentation) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            wasm.resolver_resolvePresentationIssuers(retptr, this.ptr, presentation.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Fetches the DID Document of the holder of a `Presentation`.
    *
    * ### Errors
    *
    * Errors if the holder URL is missing, is not a valid `DID`, or document resolution fails.
    * @param {Presentation} presentation
    * @returns {Promise<ResolvedDocument>}
    */
    resolvePresentationHolder(presentation) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            wasm.resolver_resolvePresentationHolder(retptr, this.ptr, presentation.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Verifies a `Presentation`.
    *
    * ### Important
    * See `PresentationValidator::validate` for information about which properties get
    * validated and what is expected of the optional arguments `holder` and `issuer`.
    *
    * ### Resolution
    * The DID Documents for the `holder` and `issuers` are optionally resolved if not given.
    * If you already have up-to-date versions of these DID Documents, you may want
    * to use `PresentationValidator::validate`.
    * See also `Resolver::resolvePresentationIssuers` and `Resolver::resolvePresentationHolder`.
    *
    * ### Errors
    * Errors from resolving the holder and issuer DID Documents, if not provided, will be returned immediately.
    * Otherwise, errors from validating the presentation and its credentials will be returned
    * according to the `fail_fast` parameter.
    * @param {Presentation} presentation
    * @param {PresentationValidationOptions} options
    * @param {number} fail_fast
    * @param {ResolvedDocument | undefined} holder
    * @param {Array<ResolvedDocument> | undefined} issuers
    * @returns {Promise<void>}
    */
    verifyPresentation(presentation, options, fail_fast, holder, issuers) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(presentation, Presentation);
            _assertClass(options, PresentationValidationOptions);
            wasm.resolver_verifyPresentation(retptr, this.ptr, presentation.ptr, options.ptr, fail_fast, isLikeNone(holder) ? 0 : addHeapObject(holder), isLikeNone(issuers) ? 0 : addHeapObject(issuers));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Resolver = Resolver;

const ResolverBuilderFinalization = new FinalizationRegistry(ptr => wasm.__wbg_resolverbuilder_free(ptr));
/**
* Builder for configuring [`Clients`][Client] when constructing a [`Resolver`].
*/
class ResolverBuilder {

    static __wrap(ptr) {
        const obj = Object.create(ResolverBuilder.prototype);
        obj.ptr = ptr;
        ResolverBuilderFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ResolverBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resolverbuilder_free(ptr);
    }
    /**
    * Constructs a new `ResolverBuilder` with no `Clients` configured.
    */
    constructor() {
        const ret = wasm.resolverbuilder_new();
        return ResolverBuilder.__wrap(ret);
    }
    /**
    * Inserts a `Client`.
    *
    * NOTE: replaces any previous `Client` or `Config` with the same network name.
    * @param {Client} client
    * @returns {ResolverBuilder}
    */
    client(client) {
        const ptr = this.__destroy_into_raw();
        _assertClass(client, Client);
        const ret = wasm.resolverbuilder_client(ptr, client.ptr);
        return ResolverBuilder.__wrap(ret);
    }
    /**
    * Inserts a `Config` used to create a `Client`.
    *
    * NOTE: replaces any previous `Client` or `Config` with the same network name.
    * @param {IClientConfig} config
    * @returns {ResolverBuilder}
    */
    clientConfig(config) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.resolverbuilder_clientConfig(retptr, ptr, addHeapObject(config));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ResolverBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Constructs a new [`Resolver`] based on the builder configuration.
    * @returns {Promise<Resolver>}
    */
    build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.resolverbuilder_build(ptr);
        return takeObject(ret);
    }
}
module.exports.ResolverBuilder = ResolverBuilder;

const RevocationBitmapFinalization = new FinalizationRegistry(ptr => wasm.__wbg_revocationbitmap_free(ptr));
/**
* A compressed bitmap for managing credential revocation.
*/
class RevocationBitmap {

    static __wrap(ptr) {
        const obj = Object.create(RevocationBitmap.prototype);
        obj.ptr = ptr;
        RevocationBitmapFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RevocationBitmapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_revocationbitmap_free(ptr);
    }
    /**
    * Creates a new `RevocationBitmap` instance.
    */
    constructor() {
        const ret = wasm.revocationbitmap_new();
        return RevocationBitmap.__wrap(ret);
    }
    /**
    * The name of the service type.
    * @returns {string}
    */
    static type() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.revocationbitmap_type(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns `true` if the credential at the given `index` is revoked.
    * @param {number} index
    * @returns {boolean}
    */
    isRevoked(index) {
        const ret = wasm.revocationbitmap_isRevoked(this.ptr, index);
        return ret !== 0;
    }
    /**
    * Mark the given index as revoked.
    *
    * Returns true if the index was absent from the set.
    * @param {number} index
    * @returns {boolean}
    */
    revoke(index) {
        const ret = wasm.revocationbitmap_revoke(this.ptr, index);
        return ret !== 0;
    }
    /**
    * Mark the index as not revoked.
    *
    * Returns true if the index was present in the set.
    * @param {number} index
    * @returns {boolean}
    */
    unrevoke(index) {
        const ret = wasm.revocationbitmap_unrevoke(this.ptr, index);
        return ret !== 0;
    }
    /**
    * Returns the number of revoked credentials.
    * @returns {number}
    */
    len() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.revocationbitmap_len(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 >>> 0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return the bitmap as a data url embedded in a service endpoint.
    * @returns {string | string[] | Map<string, string[]>}
    */
    toEndpoint() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.revocationbitmap_toEndpoint(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Construct a `RevocationBitmap` from a data `url`.
    * @param {string | string[] | Map<string, string[]>} endpoint
    * @returns {RevocationBitmap}
    */
    static fromEndpoint(endpoint) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.revocationbitmap_fromEndpoint(retptr, addHeapObject(endpoint));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RevocationBitmap.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.RevocationBitmap = RevocationBitmap;

const ServiceFinalization = new FinalizationRegistry(ptr => wasm.__wbg_service_free(ptr));
/**
* A DID Document Service used to enable trusted interactions associated
* with a DID subject.
*
* See: https://www.w3.org/TR/did-core/#services
*/
class Service {

    static __wrap(ptr) {
        const obj = Object.create(Service.prototype);
        obj.ptr = ptr;
        ServiceFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ServiceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_service_free(ptr);
    }
    /**
    * @param {IService} service
    */
    constructor(service) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.service_new(retptr, addHeapObject(service));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Service.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the `Service` id.
    * @returns {DIDUrl}
    */
    id() {
        const ret = wasm.service_id(this.ptr);
        return DIDUrl.__wrap(ret);
    }
    /**
    * Returns a copy of the `Service` type.
    * @returns {string}
    */
    type() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.service_type(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns a copy of the `Service` endpoint.
    * @returns {string | string[] | Map<string, string[]>}
    */
    serviceEndpoint() {
        const ret = wasm.service_serviceEndpoint(this.ptr);
        return takeObject(ret);
    }
    /**
    * Returns a copy of the custom properties on the `Service`.
    * @returns {Map<string, any>}
    */
    properties() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.service_properties(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Service` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.service_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Service` object from a JSON object.
    * @param {any} value
    * @returns {Service}
    */
    static fromJSON(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.service_fromJSON(retptr, addBorrowedObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Service.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {Service}
    */
    clone() {
        const ret = wasm.service_clone(this.ptr);
        return Service.__wrap(ret);
    }
}
module.exports.Service = Service;

const SignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr));
/**
*/
class Signature {

    static __wrap(ptr) {
        const obj = Object.create(Signature.prototype);
        obj.ptr = ptr;
        SignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signature_free(ptr);
    }
    /**
    * Creates a new `Signature`.
    * @param {Uint8Array} data
    */
    constructor(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.signature_new(ptr0, len0);
        return Signature.__wrap(ret);
    }
    /**
    * Returns a copy of the signature as a `UInt8Array`.
    * @returns {Uint8Array}
    */
    asBytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.signature_asBytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serializes a `Signature` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.signature_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a JSON object as `Signature`.
    * @param {any} json_value
    * @returns {Signature}
    */
    static fromJSON(json_value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.signature_fromJSON(retptr, addHeapObject(json_value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Signature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Signature = Signature;

const StorageTestSuiteFinalization = new FinalizationRegistry(ptr => wasm.__wbg_storagetestsuite_free(ptr));
/**
* A test suite for the `Storage` interface.
*
* This module contains a set of tests that a correct storage implementation
* should pass. Note that not every edge case is tested.
*
* Tests usually rely on multiple interface methods being implemented, so they should only
* be run on a fully implemented version. That's why there is not a single test case for every
* interface method.
*/
class StorageTestSuite {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        StorageTestSuiteFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_storagetestsuite_free(ptr);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static didCreateGenerateKeyTest(storage) {
        const ret = wasm.storagetestsuite_didCreateGenerateKeyTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static didCreatePrivateKeyTest(storage) {
        const ret = wasm.storagetestsuite_didCreatePrivateKeyTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static didListTest(storage) {
        const ret = wasm.storagetestsuite_didListTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static didPurgeTest(storage) {
        const ret = wasm.storagetestsuite_didPurgeTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static keyGenerateTest(storage) {
        const ret = wasm.storagetestsuite_keyGenerateTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static keyDeleteTest(storage) {
        const ret = wasm.storagetestsuite_keyDeleteTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static keyInsertTest(storage) {
        const ret = wasm.storagetestsuite_keyInsertTest(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} storage
    * @returns {Promise<void>}
    */
    static keySignEd25519Test(storage) {
        const ret = wasm.storagetestsuite_keySignEd25519Test(addHeapObject(storage));
        return takeObject(ret);
    }
    /**
    * @param {Storage} alice_storage
    * @param {Storage} bob_storage
    * @returns {Promise<void>}
    */
    static encryptionTest(alice_storage, bob_storage) {
        const ret = wasm.storagetestsuite_encryptionTest(addHeapObject(alice_storage), addHeapObject(bob_storage));
        return takeObject(ret);
    }
}
module.exports.StorageTestSuite = StorageTestSuite;

const TimestampFinalization = new FinalizationRegistry(ptr => wasm.__wbg_timestamp_free(ptr));
/**
*/
class Timestamp {

    static __wrap(ptr) {
        const obj = Object.create(Timestamp.prototype);
        obj.ptr = ptr;
        TimestampFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TimestampFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_timestamp_free(ptr);
    }
    /**
    * Parses a `Timestamp` from the provided input string.
    * @param {string} input
    * @returns {Timestamp}
    */
    static parse(input) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.timestamp_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Timestamp.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `Timestamp` with the current date and time.
    * @returns {Timestamp}
    */
    static nowUTC() {
        const ret = wasm.timestamp_nowUTC();
        return Timestamp.__wrap(ret);
    }
    /**
    * Returns the `Timestamp` as an RFC 3339 `String`.
    * @returns {string}
    */
    toRFC3339() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.timestamp_toRFC3339(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Computes `self + duration`
    *
    * Returns `null` if the operation leads to a timestamp not in the valid range for [RFC 3339](https://tools.ietf.org/html/rfc3339).
    * @param {Duration} duration
    * @returns {Timestamp | undefined}
    */
    checkedAdd(duration) {
        _assertClass(duration, Duration);
        const ret = wasm.timestamp_checkedAdd(this.ptr, duration.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Computes `self - duration`
    *
    * Returns `null` if the operation leads to a timestamp not in the valid range for [RFC 3339](https://tools.ietf.org/html/rfc3339).
    * @param {Duration} duration
    * @returns {Timestamp | undefined}
    */
    checkedSub(duration) {
        _assertClass(duration, Duration);
        const ret = wasm.timestamp_checkedSub(this.ptr, duration.ptr);
        return ret === 0 ? undefined : Timestamp.__wrap(ret);
    }
    /**
    * Serializes a `Timestamp` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.timestamp_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `Timestamp` from a JSON object.
    * @param {any} json
    * @returns {Timestamp}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.timestamp_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Timestamp.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.Timestamp = Timestamp;

const VerificationMethodFinalization = new FinalizationRegistry(ptr => wasm.__wbg_verificationmethod_free(ptr));
/**
*/
class VerificationMethod {

    static __wrap(ptr) {
        const obj = Object.create(VerificationMethod.prototype);
        obj.ptr = ptr;
        VerificationMethodFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VerificationMethodFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_verificationmethod_free(ptr);
    }
    /**
    * Creates a new `VerificationMethod` object from the given `did` and public key.
    * @param {DID} did
    * @param {number} key_type
    * @param {Uint8Array} public_key
    * @param {string} fragment
    */
    constructor(did, key_type, public_key, fragment) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(did, DID);
            const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(fragment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.verificationmethod_new(retptr, did.ptr, key_type, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerificationMethod.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns a copy of the `id` `DIDUrl` of the `VerificationMethod` object.
    * @returns {DIDUrl}
    */
    id() {
        const ret = wasm.verificationmethod_id(this.ptr);
        return DIDUrl.__wrap(ret);
    }
    /**
    * Returns a copy of the `controller` `DID` of the `VerificationMethod` object.
    * @returns {DID}
    */
    controller() {
        const ret = wasm.verificationmethod_controller(this.ptr);
        return DID.__wrap(ret);
    }
    /**
    * Sets the `controller` `DID` of the `VerificationMethod` object.
    * @param {DID} did
    */
    SetController(did) {
        _assertClass(did, DID);
        wasm.verificationmethod_SetController(this.ptr, did.ptr);
    }
    /**
    * Returns a copy of the `VerificationMethod` type.
    * @returns {MethodType}
    */
    type() {
        const ret = wasm.verificationmethod_type(this.ptr);
        return MethodType.__wrap(ret);
    }
    /**
    * Returns a copy of the `VerificationMethod` public key data.
    * @returns {MethodData}
    */
    data() {
        const ret = wasm.verificationmethod_data(this.ptr);
        return MethodData.__wrap(ret);
    }
    /**
    * Serializes a `VerificationMethod` object as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationmethod_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `VerificationMethod` object from a JSON object.
    * @param {any} value
    * @returns {VerificationMethod}
    */
    static fromJSON(value) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationmethod_fromJSON(retptr, addBorrowedObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerificationMethod.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {VerificationMethod}
    */
    clone() {
        const ret = wasm.verificationmethod_clone(this.ptr);
        return VerificationMethod.__wrap(ret);
    }
}
module.exports.VerificationMethod = VerificationMethod;

const VerifierOptionsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_verifieroptions_free(ptr));
/**
* Holds additional proof verification options.
* See `IVerifierOptions`.
*/
class VerifierOptions {

    static __wrap(ptr) {
        const obj = Object.create(VerifierOptions.prototype);
        obj.ptr = ptr;
        VerifierOptionsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    toJSON() {
        return {
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    [inspect.custom]() {
        return Object.assign(Object.create({constructor: this.constructor}), this.toJSON());
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VerifierOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_verifieroptions_free(ptr);
    }
    /**
    * Creates a new `VerifierOptions` from the given fields.
    *
    * Throws an error if any of the options are invalid.
    * @param {IVerifierOptions} options
    */
    constructor(options) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verifieroptions_new(retptr, addHeapObject(options));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerifierOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new `VerifierOptions` with default options.
    * @returns {VerifierOptions}
    */
    static default() {
        const ret = wasm.verifieroptions_default();
        return VerifierOptions.__wrap(ret);
    }
    /**
    * Serializes a `VerifierOptions` as a JSON object.
    * @returns {any}
    */
    toJSON() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verifieroptions_toJSON(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Deserializes a `VerifierOptions` from a JSON object.
    * @param {any} json
    * @returns {VerifierOptions}
    */
    static fromJSON(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verifieroptions_fromJSON(retptr, addBorrowedObject(json));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return VerifierOptions.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Deep clones the object.
    * @returns {VerifierOptions}
    */
    clone() {
        const ret = wasm.verifieroptions_clone(this.ptr);
        return VerifierOptions.__wrap(ret);
    }
}
module.exports.VerifierOptions = VerifierOptions;

const X25519Finalization = new FinalizationRegistry(ptr => wasm.__wbg_x25519_free(ptr));
/**
* An implementation of `X25519` Elliptic-curve Diffie-Hellman (ECDH) cryptographic key exchange.
*/
class X25519 {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        X25519Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_x25519_free(ptr);
    }
    /**
    * Length in bytes of an X25519 private key.
    * @returns {number}
    */
    static PRIVATE_KEY_LENGTH() {
        const ret = wasm.x25519_PRIVATE_KEY_LENGTH();
        return ret >>> 0;
    }
    /**
    * Length in bytes of an X25519 public key.
    * @returns {number}
    */
    static PUBLIC_KEY_LENGTH() {
        const ret = wasm.x25519_PUBLIC_KEY_LENGTH();
        return ret >>> 0;
    }
    /**
    * Performs Diffie-Hellman key exchange using the private key of the first party with the
    * public key of the second party, resulting in a shared secret.
    * @param {Uint8Array} privateKey
    * @param {Uint8Array} publicKey
    * @returns {Uint8Array}
    */
    static keyExchange(privateKey, publicKey) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.x25519_keyExchange(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v2 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Transforms an `Ed25519` private key to an `X25519` private key.
    *
    * This is possible because Ed25519 is birationally equivalent to Curve25519 used by X25519.
    * @param {Uint8Array} privateKey
    * @returns {Uint8Array}
    */
    static Ed25519toX25519Private(privateKey) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(privateKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.x25519_Ed25519toX25519Private(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Transforms an `Ed25519` public key to an `X25519` public key.
    *
    * This is possible because Ed25519 is birationally equivalent to Curve25519 used by X25519.
    * @param {Uint8Array} publicKey
    * @returns {Uint8Array}
    */
    static Ed25519toX25519Public(publicKey) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(publicKey, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.x25519_Ed25519toX25519Public(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.X25519 = X25519;

module.exports.__wbg_forceIntegrationUpdate_641fd7b976adff69 = function(arg0) {
    const ret = getObject(arg0).forceIntegrationUpdate;
    return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbg_fragment_25296ef0b74e471c = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_relationships_c7202aa83d5786f9 = function(arg0) {
    const ret = getObject(arg0).relationships;
    return addHeapObject(ret);
};

module.exports.__wbg_fragment_e12c852962da3c2f = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_scope_5601b30729b55bad = function(arg0) {
    const ret = getObject(arg0).scope;
    return addHeapObject(ret);
};

module.exports.__wbg_content_f0d524fd72f59620 = function(arg0) {
    const ret = getObject(arg0).content;
    return addHeapObject(ret);
};

module.exports.__wbg_fragment_a25c44360edfc7ab = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_relationships_1bf1dd48031307c9 = function(arg0) {
    const ret = getObject(arg0).relationships;
    return addHeapObject(ret);
};

module.exports.__wbg_documenthistory_new = function(arg0) {
    const ret = DocumentHistory.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_diffchainhistory_new = function(arg0) {
    const ret = DiffChainHistory.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_account_new = function(arg0) {
    const ret = Account.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_resolver_new = function(arg0) {
    const ret = Resolver.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_signWith_26510522782c9743 = function(arg0, arg1) {
    const ret = getObject(arg1).signWith;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_endpoint_89ffe3f61253a70c = function(arg0) {
    const ret = getObject(arg0).endpoint;
    return addHeapObject(ret);
};

module.exports.__wbg_properties_b83a47dc5145e6b1 = function(arg0) {
    const ret = getObject(arg0).properties;
    return addHeapObject(ret);
};

module.exports.__wbg_urls_2b5b5612ab9e9967 = function(arg0) {
    const ret = getObject(arg0).urls;
    return addHeapObject(ret);
};

module.exports.__wbg_controllers_4399724802a69314 = function(arg0) {
    const ret = getObject(arg0).controllers;
    return addHeapObject(ret);
};

module.exports.__wbg_credential_new = function(arg0) {
    const ret = Credential.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_resolveddocument_new = function(arg0) {
    const ret = ResolvedDocument.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_service_new = function(arg0) {
    const ret = Service.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbg_diffmessage_new = function(arg0) {
    const ret = DiffMessage.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_did_new = function(arg0) {
    const ret = DID.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_verificationmethod_new = function(arg0) {
    const ret = VerificationMethod.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_privateKey_f7e2aae190433242 = function(arg0, arg1) {
    const ret = getObject(arg1).privateKey;
    var ptr0 = isLikeNone(ret) ? 0 : passArray8ToWasm0(ret, wasm.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_autopublish_9d92161d27e897c1 = function(arg0) {
    const ret = getObject(arg0).autopublish;
    return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;
};

module.exports.__wbg_autosave_b8db1c486313174b = function(arg0) {
    const ret = getObject(arg0).autosave;
    return addHeapObject(ret);
};

module.exports.__wbg_clientConfig_3c2dd50a526ba96a = function(arg0) {
    const ret = getObject(arg0).clientConfig;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

module.exports.__wbg_storage_74384a6249104eeb = function(arg0) {
    const ret = getObject(arg0).storage;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

module.exports.__wbg_fragment_c8587d74bb1b41dd = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_fragment_e50e6d708e6d988c = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_client_new = function(arg0) {
    const ret = Client.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_receipt_new = function(arg0) {
    const ret = Receipt.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_id_3dc663ab7a361b11 = function(arg0) {
    const ret = getObject(arg0).id;
    return addHeapObject(ret);
};

module.exports.__wbg_serviceEndpoint_d0df0dca54fd1088 = function(arg0) {
    const ret = getObject(arg0).serviceEndpoint;
    return addHeapObject(ret);
};

module.exports.__wbg_properties_7a9978c87641ff8d = function(arg0) {
    const ret = getObject(arg0).properties;
    return addHeapObject(ret);
};

module.exports.__wbg_type_61d3194948f52780 = function(arg0, arg1) {
    const ret = getObject(arg1).type;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_presentation_new = function(arg0) {
    const ret = Presentation.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_null = function(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_document_new = function(arg0) {
    const ret = Document.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_encrypteddata_new = function(arg0) {
    const ret = EncryptedData.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_flushChanges_1b3e7070edebd3c7 = function(arg0) {
    const ret = getObject(arg0).flushChanges();
    return addHeapObject(ret);
};

module.exports.__wbg_didList_837aa54393a8ecef = function(arg0) {
    const ret = getObject(arg0).didList();
    return addHeapObject(ret);
};

module.exports.__wbindgen_json_parse = function(arg0, arg1) {
    const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === undefined ? null : obj);
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_fragment_2a56fdc975987578 = function(arg0, arg1) {
    const ret = getObject(arg1).fragment;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_type_fea5cfdd0db34544 = function(arg0, arg1) {
    const ret = getObject(arg1).type;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_didCreate_564518ce4160d06e = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
    let v0;
    if (arg5 !== 0) {
        v0 = getArrayU8FromWasm0(arg5, arg6).slice();
        wasm.__wbindgen_free(arg5, arg6 * 1);
    }
    const ret = getObject(arg0).didCreate(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), v0);
    return addHeapObject(ret);
};

module.exports.__wbg_didPurge_14c8f1f02cf5a5b5 = function(arg0, arg1) {
    const ret = getObject(arg0).didPurge(DID.__wrap(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_didExists_f3e119d2efa95097 = function(arg0, arg1) {
    const ret = getObject(arg0).didExists(DID.__wrap(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_keyGenerate_b15d8eba573d7ff9 = function(arg0, arg1, arg2, arg3, arg4) {
    try {
        const ret = getObject(arg0).keyGenerate(DID.__wrap(arg1), arg2 >>> 0, getStringFromWasm0(arg3, arg4));
        return addHeapObject(ret);
    } finally {
        wasm.__wbindgen_free(arg3, arg4);
    }
};

module.exports.__wbg_keyInsert_8a0e701b351551b6 = function(arg0, arg1, arg2, arg3, arg4) {
    var v0 = getArrayU8FromWasm0(arg3, arg4).slice();
    wasm.__wbindgen_free(arg3, arg4 * 1);
    const ret = getObject(arg0).keyInsert(DID.__wrap(arg1), KeyLocation.__wrap(arg2), v0);
    return addHeapObject(ret);
};

module.exports.__wbg_keyPublic_11a79e1b5f708b41 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).keyPublic(DID.__wrap(arg1), KeyLocation.__wrap(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_keyDelete_f01483f265a4e273 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).keyDelete(DID.__wrap(arg1), KeyLocation.__wrap(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_keySign_65f2fbbe5dee6f08 = function(arg0, arg1, arg2, arg3, arg4) {
    var v0 = getArrayU8FromWasm0(arg3, arg4).slice();
    wasm.__wbindgen_free(arg3, arg4 * 1);
    const ret = getObject(arg0).keySign(DID.__wrap(arg1), KeyLocation.__wrap(arg2), v0);
    return addHeapObject(ret);
};

module.exports.__wbg_keyExists_9f0e24a0dc921a0f = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).keyExists(DID.__wrap(arg1), KeyLocation.__wrap(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_dataEncrypt_d3fdd1572872900e = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    var v0 = getArrayU8FromWasm0(arg2, arg3).slice();
    wasm.__wbindgen_free(arg2, arg3 * 1);
    var v1 = getArrayU8FromWasm0(arg4, arg5).slice();
    wasm.__wbindgen_free(arg4, arg5 * 1);
    var v2 = getArrayU8FromWasm0(arg8, arg9).slice();
    wasm.__wbindgen_free(arg8, arg9 * 1);
    const ret = getObject(arg0).dataEncrypt(DID.__wrap(arg1), v0, v1, EncryptionAlgorithm.__wrap(arg6), CekAlgorithm.__wrap(arg7), v2);
    return addHeapObject(ret);
};

module.exports.__wbg_dataDecrypt_77871e9915a5d30e = function(arg0, arg1, arg2, arg3, arg4, arg5) {
    const ret = getObject(arg0).dataDecrypt(DID.__wrap(arg1), EncryptedData.__wrap(arg2), EncryptionAlgorithm.__wrap(arg3), CekAlgorithm.__wrap(arg4), KeyLocation.__wrap(arg5));
    return addHeapObject(ret);
};

module.exports.__wbg_chainStateGet_6e79198c588db9e7 = function(arg0, arg1) {
    const ret = getObject(arg0).chainStateGet(DID.__wrap(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_chainStateSet_da53cea6c2166f4e = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).chainStateSet(DID.__wrap(arg1), ChainState.__wrap(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_documentGet_f0d797c335fedd28 = function(arg0, arg1) {
    const ret = getObject(arg0).documentGet(DID.__wrap(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_documentSet_f41fdfb8cb62830e = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).documentSet(DID.__wrap(arg1), Document.__wrap(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_new_693216e109162396 = function() {
    const ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_fetch_b1379d93c1e2b015 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    const ret = false;
    return ret;
};

module.exports.__wbg_fetch_8c28485eb2d6317d = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_instanceof_Response_e928c54c1025470c = function(arg0) {
    const ret = getObject(arg0) instanceof Response;
    return ret;
};

module.exports.__wbg_url_0f82030e7245954c = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_status_5b4a574de7c5bbfe = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
};

module.exports.__wbg_headers_1dc1ef92ba3d32b1 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
};

module.exports.__wbg_text_5cb78830c1a11c5b = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).text();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_now_9c64828adecad05e = function(arg0) {
    const ret = getObject(arg0).now();
    return ret;
};

module.exports.__wbg_newwithstrandinit_41c86e821f771b24 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_483f23f84dfd2751 = function() { return handleError(function () {
    const ret = new Headers();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_append_fcf64231455390c4 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
}, arguments) };

module.exports.__wbg_clearTimeout_65417660fe82f08d = typeof clearTimeout == 'function' ? clearTimeout : notDefined('clearTimeout');

module.exports.__wbg_setTimeout_131fc254e1bd5624 = function() { return handleError(function (arg0, arg1) {
    const ret = setTimeout(getObject(arg0), arg1);
    return ret;
}, arguments) };

module.exports.__wbg_process_e56fd54cf6319b6c = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbg_versions_77e21455908dad33 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
};

module.exports.__wbg_node_0dd25d832e4785d5 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_string = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
};

module.exports.__wbg_require_0db1598d9ccecb30 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_crypto_b95d7173266618a9 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbg_msCrypto_5a86d77a66230f81 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

module.exports.__wbg_getRandomValues_b14734aa289bc356 = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) };

module.exports.__wbg_static_accessor_NODE_MODULE_26b231378c1be7dd = function() {
    const ret = module;
    return addHeapObject(ret);
};

module.exports.__wbg_randomFillSync_91e2b39becca6147 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_get_f0f4f1608ebf633e = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
};

module.exports.__wbg_length_93debb0e2e184ab6 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_new_2ab697f1555e0dbc = function() {
    const ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_function = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbg_newnoargs_fc5356289219b93b = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_new_f0540490a24a79bb = function() {
    const ret = new Map();
    return addHeapObject(ret);
};

module.exports.__wbg_next_0e1ee6203bc0f8ed = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
};

module.exports.__wbg_next_9ef803116340cdc1 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).next();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_done_2a1e30464aae6a4d = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_a495c29471c31da6 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_iterator_6ac6eb1e020f18e3 = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
};

module.exports.__wbg_get_89247d3aeaa38cc5 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_call_4573f605ca4b5f10 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_306ce8d57919e6ae = function() {
    const ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbg_self_ba1ddafe9ea7a3a2 = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_window_be3cc430364fd32c = function() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_globalThis_56d9c9f814daeeee = function() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_global_8c35aeee4ac77f2b = function() { return handleError(function () {
    const ret = global.global;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_from_7ff9036e9b5c3ccb = function(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_push_811c8b08bf4ff9d5 = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_instanceof_Error_53fd3b982f19be06 = function(arg0) {
    const ret = getObject(arg0) instanceof Error;
    return ret;
};

module.exports.__wbg_new_651776e932b7e9c7 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_setname_c41f156664cf0ab9 = function(arg0, arg1, arg2) {
    getObject(arg0).name = getStringFromWasm0(arg1, arg2);
};

module.exports.__wbg_toString_ef76a2af8f5bb98a = function(arg0) {
    const ret = getObject(arg0).toString();
    return addHeapObject(ret);
};

module.exports.__wbg_call_9855a4612eb496cb = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_instanceof_Map_9e1310ea011d1721 = function(arg0) {
    const ret = getObject(arg0) instanceof Map;
    return ret;
};

module.exports.__wbg_set_e44d2fe94a18567f = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_now_513c8208bd94c09b = function() {
    const ret = Date.now();
    return ret;
};

module.exports.__wbg_fromEntries_06150f1d39e0a856 = function() { return handleError(function (arg0) {
    const ret = Object.fromEntries(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_78403b138428b684 = function(arg0, arg1) {
    try {
        var state0 = {a: arg0, b: arg1};
        var cb0 = (arg0, arg1) => {
            const a = state0.a;
            state0.a = 0;
            try {
                return __wbg_adapter_655(a, state0.b, arg0, arg1);
            } finally {
                state0.a = a;
            }
        };
        const ret = new Promise(cb0);
        return addHeapObject(ret);
    } finally {
        state0.a = state0.b = 0;
    }
};

module.exports.__wbg_resolve_f269ce174f88b294 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_then_1c698eedca15eed6 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_then_4debc41d4fc92ce5 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_buffer_de1150f91b23aa89 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_newwithbyteoffsetandlength_9ca61320599a2c84 = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_new_97cf52648830a70d = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_a0172b213e2469e9 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_length_e09c0b925ab8de5d = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_instanceof_Uint8Array_fd17ec67c77de602 = function(arg0) {
    const ret = getObject(arg0) instanceof Uint8Array;
    return ret;
};

module.exports.__wbg_newwithlength_e833b89f9db02732 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_subarray_9482ae5cd5cd99d3 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_has_ded5f0e31f1ff6ad = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.has(getObject(arg0), getObject(arg1));
    return ret;
}, arguments) };

module.exports.__wbg_set_b12cd0ab82903c2f = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
    return ret;
}, arguments) };

module.exports.__wbg_stringify_cf20dc96bee34a66 = function() { return handleError(function (arg0) {
    const ret = JSON.stringify(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper8805 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1515, __wbg_adapter_34);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper10366 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1752, __wbg_adapter_37);
    return addHeapObject(ret);
};

const path = require('path').join(__dirname, 'identity_wasm_bg.wasm');
const bytes = require('fs').readFileSync(path);

const wasmModule = new WebAssembly.Module(bytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;
module.exports.__wasm = wasm;

cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);

wasm.__wbindgen_start();

