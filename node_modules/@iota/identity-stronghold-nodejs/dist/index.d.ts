import { Storage, DID, KeyLocation, KeyType, Signature, EncryptionAlgorithm, CekAlgorithm, EncryptedData, ChainState, Document } from '@iota/identity-wasm/node';

declare class Stronghold implements Storage {
    private napiStronghold;
    constructor();
    init(snapshot: string, password: string, dropsave?: boolean): Promise<void>;
    static build(snapshot: string, password: string, dropsave?: boolean): Promise<Stronghold>;
    didCreate(network: string, fragment: string, private_key?: Uint8Array): Promise<[DID, KeyLocation]>;
    didPurge(did: DID): Promise<boolean>;
    didExists(did: DID): Promise<boolean>;
    didList(): Promise<Array<DID>>;
    keyGenerate(did: DID, keyType: KeyType, fragment: string): Promise<KeyLocation>;
    keyInsert(did: DID, keyLocation: KeyLocation, privateKey: Uint8Array): Promise<void>;
    keyExists(did: DID, keyLocation: KeyLocation): Promise<boolean>;
    keyPublic(did: DID, keyLocation: KeyLocation): Promise<Uint8Array>;
    keyDelete(did: DID, keyLocation: KeyLocation): Promise<boolean>;
    keySign(did: DID, keyLocation: KeyLocation, data: Uint8Array): Promise<Signature>;
    dataEncrypt(did: DID, plaintext: Uint8Array, associatedData: Uint8Array, encryptionAlgorithm: EncryptionAlgorithm, cekAlgorithm: CekAlgorithm, publicKey: Uint8Array): Promise<EncryptedData>;
    dataDecrypt(did: DID, data: EncryptedData, encryptionAlgorithm: EncryptionAlgorithm, cekAlgorithm: CekAlgorithm, privateKey: KeyLocation): Promise<Uint8Array>;
    chainStateGet(did: DID): Promise<ChainState | undefined>;
    chainStateSet(did: DID, chainState: ChainState): Promise<void>;
    documentGet(did: DID): Promise<Document | undefined>;
    documentSet(did: DID, document: Document): Promise<void>;
    flushChanges(): Promise<void>;
}

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

const enum NapiKeyType {
  Ed25519 = 0,
  X25519 = 1
}
declare class NapiStronghold {
  /**
   * Workaround for Napi not generating code when no factory or constructor is present, and
   * async constructors are not possible.
   */
  static f(): NapiStronghold
  /** Creates an instance of `Stronghold`. */
  static new(snapshot: string, password: string, dropsave?: boolean | undefined | null): Promise<NapiStronghold>
  /** Returns whether save-on-drop is enabled. */
  get dropsave(): boolean
  /**
   * Set whether to save the storage changes on drop.
   * Default: true
   */
  set dropsave(dropsave: boolean)
  /**
   * Creates a new identity for the given `network`.
   *
   * - Uses the given Ed25519 `private_key` or generates a new key if it's `None`.
   * - Returns an error if the DID already exists.
   * - Adds the newly created DID to a list which can be accessed via `did_list`.
   *
   * Returns the generated DID and the location at which the key was stored.
   */
  didCreate(network: string, fragment: string, privateKey?: Array<number> | undefined | null): Promise<NapiDidLocation>
  /**
   * Removes the keys and any other state for the given `did`.
   *
   * This operation is idempotent: it does not fail if the given `did` does not (or no longer) exist.
   *
   * Returns `true` if the did and its associated data was removed, `false` if nothing was done.
   */
  didPurge(did: NapiDid): Promise<boolean>
  /** Returns `true` if `did` exists in the list of stored DIDs. */
  didExists(did: NapiDid): Promise<boolean>
  /** Returns the list of stored DIDs. */
  didList(): Promise<Array<NapiDid>>
  /**
   * Generates a new key for the given `did` with the given `key_type` and `fragment` identifier
   * and returns the location of the newly generated key.
   */
  keyGenerate(did: NapiDid, keyType: NapiKeyType, fragment: string): Promise<NapiKeyLocation>
  /**
   * Inserts a private key at the specified `location`.
   *
   * If a key at `location` exists, it is overwritten.
   */
  keyInsert(did: NapiDid, location: NapiKeyLocation, privateKey: Array<number>): Promise<void>
  /** Retrieves the public key from `location`. */
  keyPublic(did: NapiDid, location: NapiKeyLocation): Promise<Array<number>>
  /**
   * Deletes the key at `location`.
   *
   * This operation is idempotent: it does not fail if the key does not exist.
   *
   * Returns `true` if it removed the key, `false` if nothing was done.
   */
  keyDelete(did: NapiDid, location: NapiKeyLocation): Promise<boolean>
  /** Signs `data` with the private key at the specified `location`. */
  keySign(did: NapiDid, location: NapiKeyLocation, data: Array<number>): Promise<NapiSignature>
  /** Returns `true` if a key exists at the specified `location`. */
  keyExists(did: NapiDid, location: NapiKeyLocation): Promise<boolean>
  /**
   * Encrypts the given `plaintext` with the specified `encryption_algorithm` and `cek_algorithm`.
   *
   * Returns an [`EncryptedData`] instance.
   */
  dataEncrypt(did: NapiDid, plaintext: Array<number>, associatedData: Array<number>, encryptionAlgorithm: NapiEncryptionAlgorithm, cekAlgorithm: NapiCekAlgorithm, publicKey: Array<number>): Promise<NapiEncryptedData>
  /**
   * Decrypts the given `data` with the specified `encryption_algorithm` and `cek_algorithm`.
   *
   * Returns the decrypted text.
   */
  dataDecrypt(did: NapiDid, data: NapiEncryptedData, encryptionAlgorithm: NapiEncryptionAlgorithm, cekAlgorithm: NapiCekAlgorithm, privateKey: NapiKeyLocation): Promise<Array<number>>
  /** Returns the chain state of the identity specified by `did`. */
  chainStateGet(did: NapiDid): Promise<NapiChainState | null>
  /** Set the chain state of the identity specified by `did`. */
  chainStateSet(did: NapiDid, chainState: NapiChainState): Promise<void>
  /** Returns the document of the identity specified by `did`. */
  documentGet(did: NapiDid): Promise<NapiDocument | null>
  /** Sets a new state for the identity specified by `did`. */
  documentSet(did: NapiDid, state: NapiDocument): Promise<void>
  /** Persists any unsaved changes. */
  flushChanges(): Promise<void>
}
declare class NapiCekAlgorithm {
  static fromJSON(jsonValue: any): NapiCekAlgorithm
  toJSON(): any
}
declare class NapiChainState {
  static fromJSON(jsonValue: any): NapiChainState
  toJSON(): any
}
declare class NapiEncryptionAlgorithm {
  static fromJSON(jsonValue: any): NapiEncryptionAlgorithm
  toJSON(): any
}
declare class NapiEncryptedData {
  static fromJSON(jsonValue: any): NapiEncryptedData
  toJSON(): any
}
declare class NapiDid {
  static fromJSON(jsonValue: any): NapiDid
  toJSON(): any
}
declare class NapiDocument {
  static fromJSON(jsonValue: any): NapiDocument
  toJSON(): any
}
declare class NapiKeyLocation {
  static fromJSON(jsonValue: any): NapiKeyLocation
  toJSON(): any
}
declare class NapiSignature {
  static fromJSON(jsonValue: any): NapiSignature
  toJSON(): any
}
declare class NapiDidLocation {
  did(): NapiDid
  keyLocation(): NapiKeyLocation
  static fromJSON(jsonValue: any): NapiDidLocation
  toJSON(): any
}

export { NapiCekAlgorithm, NapiChainState, NapiDid, NapiDidLocation, NapiDocument, NapiEncryptedData, NapiEncryptionAlgorithm, NapiKeyLocation, NapiKeyType, NapiSignature, NapiStronghold, Stronghold };
